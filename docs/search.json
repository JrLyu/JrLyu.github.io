[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jiuru Lyu",
    "section": "",
    "text": "Hi! My name is Jiuru Lyu, and I am a junior at Emory University studying Applied Mathematics. In my leisure time, I enjoy coffee brewing, traveling, photograph, and commercial aviation.\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Class Notes",
    "section": "",
    "text": "High School Level Math\nIB Math AA HL Notes\n\n\nCollege Level Math\n\nMath Fundamentals\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\nProof Practice\n\n\nApplied Mathematics\n(Ordinary) Differential Equations\nNonlinear Optimization\nNumerical Analysis\n\n\nData Science, Statistics, and Causal Inference\nIntroduction to Causal Inference\nMathematical Statistics I: Probability\nMathematical Statistics II: Statistical Inference\nGoogle Data Analytics Learning Notes\n\n\n\nComputer Science\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\n\n\nOther Fields\nIntroduction to Sociology"
  },
  {
    "objectID": "about.html#high-school-level-math",
    "href": "about.html#high-school-level-math",
    "title": "Class Notes",
    "section": "",
    "text": "IB Math AA HL Notes\nCollege Level Math Math Fundamentals\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\nProof Practice\nApplied Mathematics\n(Ordinary) Differential Equations\nNonlinear Optimization\nNumerical Analysis\nData Science, Statistics, and Causal Inference\nIntroduction to Causal Inference\nMathematical Statistics I: Probability\nMathematical Statistics II: Statistical Inference\nGoogle Data Analytics Learning Notes\nComputer Science\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\nOther Fields\nIntroduction to Sociology"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Class Notes",
    "section": "",
    "text": "High School Level Math\n\nIB Math AA HL Notes\n\n\n\nCollege Level Math\n\nMath Fundamentals\n\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\n\n\n\nApplied Mathematics\n\nOrdinary Differential Equations\nNonlinear Optimization\nUndergraduate-Level Numerical Analysis\n\n\n\nData Science, Statistics, and Causal Inference\n\nIntroduction to Causal Inference\nMathematical Statistics\nGoogle Data Analytics Learning Notes\n\n\n\n\nComputer Science\n\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\n\n\n\nOther Fields\n\nIntroduction to Sociology\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "CV",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/MathStats.html#statistical-inference",
    "href": "notes/MathStats.html#statistical-inference",
    "title": "Mathematical Statistics",
    "section": "Statistical Inference",
    "text": "Statistical Inference"
  },
  {
    "objectID": "notes/Proofs.html#proof-practice",
    "href": "notes/Proofs.html#proof-practice",
    "title": "IB Math AA HL Notes",
    "section": "Proof Practice",
    "text": "Proof Practice"
  },
  {
    "objectID": "notes/LA.html#linear-algebra-done-right",
    "href": "notes/LA.html#linear-algebra-done-right",
    "title": "Linear Algebra",
    "section": "Linear Algebra Done Right",
    "text": "Linear Algebra Done Right"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "My Blogs",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nblog post title\n\n\n\nQuarto\n\n\nTest\n\n\nBlog\n\n\n\nblog post description (appears underneath the title in smaller text) which is included on the listing page\n\n\n\nJiuru Lyu\n\n\nOct 26, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "blogs/2024-10-26-test-blog/index.html",
    "href": "blogs/2024-10-26-test-blog/index.html",
    "title": "blog post title",
    "section": "",
    "text": "This is my test-blog to show case how to generate a blog post in Quarto.\n\n\nIt is important to note that the front matter of the blog post is different from the front matter of the index page, notes page, and blogs page. The front matter of the blog post is used to provide metadata about the blog post, such as the title, description, author, date, categories, image, and draft status. The content of the blog post is written in markdown and can include text, images, links, and other markdown elements."
  },
  {
    "objectID": "blogs/2024-10-26-test-blog/index.html#footnotes",
    "href": "blogs/2024-10-26-test-blog/index.html#footnotes",
    "title": "blog post title",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAlso see other useful blogs as reference!↩︎"
  },
  {
    "objectID": "blogs/2024-10-26-test-blog/index.html#some-random-thoughts",
    "href": "blogs/2024-10-26-test-blog/index.html#some-random-thoughts",
    "title": "blog post title",
    "section": "",
    "text": "It is important to note that the front matter of the blog post is different from the front matter of the index page, notes page, and blogs page. The front matter of the blog post is used to provide metadata about the blog post, such as the title, description, author, date, categories, image, and draft status. The content of the blog post is written in markdown and can include text, images, links, and other markdown elements."
  },
  {
    "objectID": "notes/cs171.html",
    "href": "notes/cs171.html",
    "title": "CS 171 Introduction to Computer Science II",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nLecture 1 Introduction & Review\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nAlgorithm\n\n\nOOP\n\n\nData Structure\n\n\n\nThis lecture introduces the purpose of studying algorithms and data structures. It also does some review on Java and its code basics.\n\n\n\n\n\nAug 29, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 2 Objects and Classes\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nObjects\n\n\nClass\n\n\n\nThis lecture introduces the concepts of OOP in Java.\n\n\n\n\n\nSep 7, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 3 Packages\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nPakcage\n\n\n\nBased on Objects and Classes, this lecture extends the idea and introduces Packages and how it works in Java.\n\n\n\n\n\nSep 16, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 4 Inheritance and Polymorphism\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nInhertiance\n\n\nPolymorphism\n\n\n\nThis lecture is a more detailed lecture on inheritance and polymorphism, two very essential concepts in OOP.\n\n\n\n\n\nSep 19, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 5 Abstract Classes and Interfaces\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nInterface\n\n\nAbstract Class\n\n\n\nThis lecture touches on abstract classes and extends it to interfaces. It also introduces Iterator and Iterable interfaces in Java and how to use them in practice. \n\n\n\n\n\nOct 4, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 6 Generic Classes and Generic Methods\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nGenerics\n\n\n\nThis lecture discusses the use of generic class and generic methods in Java. It also touches on the use of generic classes in practice.\n\n\n\n\n\nOct 10, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 7 Array Data Structure\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nArray\n\n\n\nStarting from this lecture, we discuss some data structures. The very basic data structure of discussion is the array data structure.\n\n\n\n\n\nOct 14, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 8 Stack\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nStack\n\n\n\nThis lecture discusses the stack data structure and its implementation in Java.\n\n\n\n\n\nOct 18, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 9 Queue Data Structure\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nQueue\n\n\n\nThis lecture discusses the queue data structure and its implementation in Java.\n\n\n\n\n\nOct 18, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 10 Linked List\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nLinked List\n\n\n\nThis lecture discusses the linked list data structure and its implementation in Java.\n\n\n\n\n\nNov 2, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 11 Complexity Analysis\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nAlgorithms\n\n\nComplexity Analysis\n\n\n\nStarting from this lecture, we will discuss some sorting algorithms and their complexity analysis. This lecture offers an overview of running time analysis.\n\n\n\n\n\nNov 11, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 12 Sorting Algorithms\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nAlgorithms\n\n\nSorting\n\n\n\nThis lecture discusses various sorting algorithms and their implementation in Java. It also touches on the runtime analysis of them.\n\n\n\n\n\nDec 4, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 13 Hashing (Hash Table): Implementation and Runtime Analysis\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nAlgorithms\n\n\nHash Table\n\n\nHashing\n\n\n\nThis lecture discusses the hashing algorithm and the hash table data structure. It also covers the implementation of the hash table and the runtime analysis of the hash table operations.\n\n\n\n\n\nDec 6, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html",
    "title": "Lecture 8 Stack",
    "section": "",
    "text": "There are 2 commonly used data structures:\n\nStack (LIFO)\nQueue (FIFO)\n\nA stack is a data structure that organize the stored data in a Last In First Out (LIFO) manner.\nTo achieve the LIFO behavior, the stack only provide the following 2 methods to access the data stored in a stack:\n\npush(x): add x to the “top” of the stack.\npop(): remove the item at the “top” of the stack and return it.\nThe item removed by pop() is always the last item that was pushed.\n\nMethod invocation/return:\n\nIf the order of method invocation is\n\nM1() --&gt; M2() --&gt; M3() --&gt; M4()\n\nThen the order in which the methods return form their invocation is the reverse order:\n\nM4() --&gt; M3() --&gt; M2() --&gt; M1()\n\nSome computer algorithms/processes with a natural LIFO behavior: undo algorithm in a text editor (it uses a stack to store the history of edit changes); back algorithm in a browser (it uses a stack to store the browser history)"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#introduction-to-stack",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#introduction-to-stack",
    "title": "Lecture 8 Stack",
    "section": "",
    "text": "There are 2 commonly used data structures:\n\nStack (LIFO)\nQueue (FIFO)\n\nA stack is a data structure that organize the stored data in a Last In First Out (LIFO) manner.\nTo achieve the LIFO behavior, the stack only provide the following 2 methods to access the data stored in a stack:\n\npush(x): add x to the “top” of the stack.\npop(): remove the item at the “top” of the stack and return it.\nThe item removed by pop() is always the last item that was pushed.\n\nMethod invocation/return:\n\nIf the order of method invocation is\n\nM1() --&gt; M2() --&gt; M3() --&gt; M4()\n\nThen the order in which the methods return form their invocation is the reverse order:\n\nM4() --&gt; M3() --&gt; M2() --&gt; M1()\n\nSome computer algorithms/processes with a natural LIFO behavior: undo algorithm in a text editor (it uses a stack to store the history of edit changes); back algorithm in a browser (it uses a stack to store the browser history)"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#the-stack-interface",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#the-stack-interface",
    "title": "Lecture 8 Stack",
    "section": "The Stack Interface",
    "text": "The Stack Interface\n\nThe stack interface definition:\n\nThe stack only defines a behavior on the access of the data stored in a stack: pop() must return the last item that was pushed\nThe stack does not specify how the data must be stored.\nThere are different ways to implement the same behavior\n\npublic interface MyStackInterface&lt;E&gt; {\n  boolean isEmpty(); // returns true if stack is empty\n  boolean isFull(); // returns true if stack is full\n  void push(E e); // pushes element e on the stack\n  E pop(); // Remove the element at the top of the stack and return it\n  E peek(); // Return the element at the top without removing it\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implementing-the-stack-with-a-fixed-size-array",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implementing-the-stack-with-a-fixed-size-array",
    "title": "Lecture 8 Stack",
    "section": "Implementing the Stack with a fixed size array",
    "text": "Implementing the Stack with a fixed size array\n\nThe basic implementation of a Stack is using:\n\nA fixed size array to store the data items\nA stackTop index variable to record the first open position in the array\n\nThe initial state of the stack when it is instantiated (=created): stackTop = 0 (can also use stackTop = -1)\n\npublic class IntegerStack implements Stack&lt;Integer&gt; {\n    private Integer[] item;\n    private int stackTop;\n    public IntegerStack(int N) { // Create a stack of size N\n        item = new Integer[N];\n        stackTop = 0;\n    }\n    public boolean isEmpty() { // Test if stack is empty\n        return stackTop == 0;\n    }\n    public boolean isFull() { // Test if stack is empty\n        return stackTop == item.length;\n    }\n    public void push(Integer e) {\n        if (isFull()) {\n            System.out.println(\"Full\");\n            return; // Or: throw an exception\n        }\n        item[stackTop] = e; // (1) store item\n        stackTop++; // (2) increment stackTop\n    }\n    public Integer pop() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\");\n            return null; // Or: throw an exception\n        }\n        stackTop--; // (1) decrement stackTop\n        return item[stackTop]; // (2) return item\n    }\n}\n\nSee IntegerStack.java and TestIntegerStack.java."
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implement-the-stack-with-a-dynamic-array",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implement-the-stack-with-a-dynamic-array",
    "title": "Lecture 8 Stack",
    "section": "Implement the stack with a dynamic array",
    "text": "Implement the stack with a dynamic array\n\nThe stack can be implemented using a dynamic array\n\npublic class IntegerStack implements Stack&lt;Integer&gt; {\n    private Integer[] item;\n    private int stackTop;\n    private final double DELTA = 0.25;\n    \n    public IntegerStack(int N) { // Create a stack of size N\n        item = new Integer[N];\n        stackTop = 0;\n    }\n    public boolean isEmpty() { // Test if stack is empty\n        return stackTop == 0;\n    }\n    public boolean isFull() { // Test if stack is empty\n        return stackTop == item.length;\n    }\n    public void push(Integer e) {\n        if (isFull()) {\n            // Double the array size\n            Integer[] temp = new int[2 * item.length];\n            for (int i = 0; i &lt; item.length; i++) {\n                temp[i] = item[i];\n            }\n            item = temp;\n        }\n        item[stackTop] = e; // (1) store item\n        stackTop++; // (2) increment stackTop\n    }\n    public Integer pop() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\");\n            return null; // Or: throw an exception\n        }\n        stackTop--; // (1) decrement stackTop\n        Integer retVal = item[stackTop];\n        if (stackTop &lt; DELTA * item.length && item.length &gt;= 2) {\n            // Reduce the array by half\n            temp = new int[item.length / 2];\n            for (int i = 0; i &lt;= stackTop; i++) {\n                temp[i] = item[i];\n            }\n            item = temp;\n        }\n        return retVal; // (2) return item\n    }\n}\n\nThe value DELTA determines when we will reduce the size of the array: DELTA is a wastage threshold:\n\nWhen only the fraction of DELTA of the array is being used, we will reduce the wastage.\nSince we will reduce the array by half, DELTA must be at most 0.5. Otherwise, we will discard some valid entries in the stack.\nDELTA = 0.25 is actually better than 0.5\n\nRunning Time Analysis: Consider the push() algorithm using a dynamic array. On average, how many “store” statements are executed for each push() invocation?\n\nWhen the stack is not full, the push() invocation will execute 1 store statement.\nWhen the stack if full, the push() invocation will execute (1 + item.length) store statement.\nSuppose we execute \\(N\\) push() operations:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# times exec push()\n1\n2\n3\n4\n5\n6\n7\n8\n\\(\\cdots\\)\n\\(N\\)\n\n\n\n\n# store statements to store item pushed\n1\n1\n1\n1\n1\n1\n1\n1\n\\(\\cdots\\)\n1\n\n\n# store statements to double array\n1\n2\n0\n4\n0\n0\n0\n8\n\\(\\cdots\\)\n\\(M\\leq N\\)\n\n\n\n\nTherefore, total store statements executed for \\(N\\) push() invocations: \\[(1+1+\\cdots+1)+(1+2+4+\\cdots+M)\\text{ where }M\\le N\\]\n\nConsider \\(S=1+2+4+\\cdots+M\\): \\[\\begin{aligned}S=1+&2+4+\\cdots+M\\\\2S=\\quad\\ \\ &2+4+8+\\cdots+2M\\\\S=2S-S&=2M-1\\end{aligned}\\]\nTherefore, total store statements executed is \\[N+(2*M-1)\\leq N+2*N-1=3N-1\\]\nHence, average # store statement for 1 push() invocation is \\(\\dfrac{(3N-1)}{N}\\approx3\\)."
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#generic-stack",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#generic-stack",
    "title": "Lecture 8 Stack",
    "section": "Generic Stack",
    "text": "Generic Stack\n\nJava does not allow instantiation of a generic array, so the following code will cause error messages:\n\npublic class ArrayStack&lt;T&gt; implements Stack&lt;T&gt; {\n    private T[] item;\n    private int stackTop;\n\n    public ArrayStack(int N) {\n        item = new T[N]; // Create an array of T objects --&gt; error\n        stackTop = 0;\n    }\n    // other methods...\n}\n\nHowever, there’s a simple hack to work around this Java restriction.\n\npublic class ArrayStack&lt;T&gt; implements Stack&lt;T&gt; {\n    private T[] item;\n    private int stackTop;\n\n    public ArrayStack(int N) {\n        item = (T[]) new Object[N]; // Create an array of Object objects, and casting\n        stackTop = 0;\n    }\n    // other methods...\n}\n\nIn this way, Java will report warning messages (not fatal errors), so our program will still compile and run.\n\npublic class GenericStack&lt;T&gt; implements MyStackInterface&lt;T&gt; {\n    private T[] item;\n    private int stackTop;\n\n    public GenericStack(int N) {\n        item = (T[]) new Object[N]; // Create an array of Object objects\n        // This will cause some warning, but it will compile (Java does not know if the casting will be successful)\n        // Why this will work: If we are working with unbounded generic types,\n        // we know T will be interpreted as Object by Java. Then we will create\n        // an array of Object, then cast it into our desired type T\n        stackTop = 0;\n    }\n    @Override\n    public boolean isEmpty() {\n        return stackTop == 0;\n    }\n\n    @Override\n    public boolean isFull() {\n        return stackTop == item.length;\n    }\n\n    @Override\n    public void push(T t) {\n        // if the array is full, then double the size of the array\n        if (isFull()) {\n            System.out.println(\"Full\");\n            return;\n        }\n        item[stackTop] = t;\n        stackTop++;\n    }\n\n    @Override\n    public T pop() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\");\n            return null; // or throw an exception\n        }\n        stackTop--; // (1) decrease stackTop\n        return item[stackTop]; // return item\n    }\n\n    @Override\n    public T peek() {\n        return item[stackTop - 1];\n    }\n\n    public String toString(){\n        String result = \"\";\n        for (int i = 0; i &lt; stackTop; i++) {\n            result += item[i] + \" \";\n        }\n        return result;\n    }\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#javas-stack-library",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#javas-stack-library",
    "title": "Lecture 8 Stack",
    "section": "Java’s Stack Library",
    "text": "Java’s Stack Library\n\nThe Java library contains a generic Stack class: java.util.Stack\nTo instantiate Stack objects:\n\nStack&lt;Integer&gt; iStack = new Stack&lt;&gt;(); // Integer Stack\nStack&lt;String&gt; sStack = new Stack&lt;&gt;(); // String Stack\n\nThe Stack class contains the following instance methods: boolean empty(); E peek(); E push(E item); E pop().\nFor some reasons, the Stack class is a subclass of the Vector class, which can access the sotred data using an index.\n\nAs a subclass, Stack inherits those methods:\n\nget(int index); // Returns the element at the specified position\nremove(int index); // Removes the element at the specified position\n\nHowever, this inheritance makes the FIFO behavior not guaranteed. ## Application of Stack: Reverse Polish Expression Evaluation\n\nThere are 3 ways to write arithmetic expressions:\n\nIn-fix: operators are placed between their operands: \\((A+B)\\times C=(A+B)\\times C\\).\nPre-fix: operators are placed before their operands: \\(\\times + A\\ B\\ C\\ =(A + B)\\times C\\).\nPost-fix: operators are placed after their operands: \\(A\\ B+C\\times=(A+B)\\times C\\).\nThe pre-fix and post-fix notations do no use parenthesis to write arithmetic expressions.\n\nReverse Polish Notation (RPN):\n\nThe operator always follows its (2) operands: 3 4 + ==&gt; 3 + 4 = 7\nWhen we evaluate an operation in RPN, the result is used an operand of another operation: 3 4 + 1 - ==&gt; 7 1 - ==&gt; 6\nConclusion:\n\nEach operator will operate on its proceeding 2 operands.\nEach operator will produce a result that will be the operand of some subsequent operator.\n\nWe use a stack to store the operands. Whenever we reach an operator, we evaluate the operation with the two operands at the top of the stack.\n\nimport java.util.Stack;\npublic class EavluatePRN {\n  public static void main(String[] args) {\n      System.out.println(evalRPN(args));\n  }\n\n  /**\n   * Reverse Polish Notation (RPN):\n   *      3 4 + ===&gt; 3 + 4 = 7\n   *      - Each operator will operate on its proceeding 2 operands\n   *      - Each operator will produce a result that will be the operand of some subsequent operator\n   * We will use a Stack to implement this algorithm\n   * @param inp = array of String representing an RPN expression (e.g.: \"3\" \"4\" \"+')\n   */\n  public static int evalRPN(String[] inp) {\n      Stack&lt;Integer&gt; opStack = new Stack&lt;&gt;(); // Stack containing the prior oprands\n      String s; // Help variable containg the next symbol\n      for (int i = 0; i &lt; inp.length; i++) {\n          s = inp[i]; // s = next item/symbol in input (as String !)\n          if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"x\") || s.equals(\"/\")) {\n              // the next symbol is an operator\n              int o2 = opStack.pop(); // Get the last 2 operands\n              int o1 = opStack.pop();\n\n              int r = operate(s, o1, o2); // Perform operation\n              opStack.push(r); // Save result (operand) on stack\n\n          } else { // the next symbol is an oprands\n              opStack.push(Integer.parseInt(s)); // Save number as Integer\n          }\n      }\n      return opStack.pop(); // Return result (was saved on stack)\n  }\n\n  public static int operate(String op, int o1, int o2) {\n      if (op.equals(\"x\")) { // Multiply\n          return o1 * o2;\n      } else if (op.equals(\"/\")) {\n          return o1/o2;\n      } else if (op.equals(\"+\")) {\n          return o1 + o2;\n      }\n      else if (op.equals(\"-\")) {\n          return o1 - o2;\n      } else {\n          return 0;\n      }\n  }\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#application-of-stack-reverse-polish-expression-evaluation",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#application-of-stack-reverse-polish-expression-evaluation",
    "title": "Lecture 8 Stack",
    "section": "Application of Stack: Reverse Polish Expression Evaluation",
    "text": "Application of Stack: Reverse Polish Expression Evaluation\n\nThere are 3 ways to write arithmetic expressions:\n\nIn-fix: operators are placed between their operands: \\((A+B)\\times C=(A+B)\\times C\\).\nPre-fix: operators are placed before their operands: \\(\\times + A\\ B\\ C\\ =(A + B)\\times C\\).\nPost-fix: operators are placed after their operands: \\(A\\ B+C\\times=(A+B)\\times C\\).\nThe pre-fix and post-fix notations do no use parenthesis to write arithmetic expressions.\n\nReverse Polish Notation (RPN):\n\nThe operator always follows its (2) operands: 3 4 + ==&gt; 3 + 4 = 7\nWhen we evaluate an operation in RPN, the result is used an operand of another operation: 3 4 + 1 - ==&gt; 7 1 - ==&gt; 6\nConclusion:\n\nEach operator will operate on its proceeding 2 operands.\nEach operator will produce a result that will be the operand of some subsequent operator.\n\nWe use a stack to store the operands. Whenever we reach an operator, we evaluate the operation with the two operands at the top of the stack.\n\nimport java.util.Stack;\npublic class EavluatePRN {\n  public static void main(String[] args) {\n      System.out.println(evalRPN(args));\n  }\n\n  /**\n   * Reverse Polish Notation (RPN):\n   *      3 4 + ===&gt; 3 + 4 = 7\n   *      - Each operator will operate on its proceeding 2 operands\n   *      - Each operator will produce a result that will be the operand of some subsequent operator\n   * We will use a Stack to implement this algorithm\n   * @param inp = array of String representing an RPN expression (e.g.: \"3\" \"4\" \"+')\n   */\n  public static int evalRPN(String[] inp) {\n      Stack&lt;Integer&gt; opStack = new Stack&lt;&gt;(); // Stack containing the prior oprands\n      String s; // Help variable containg the next symbol\n      for (int i = 0; i &lt; inp.length; i++) {\n          s = inp[i]; // s = next item/symbol in input (as String !)\n          if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"x\") || s.equals(\"/\")) {\n              // the next symbol is an operator\n              int o2 = opStack.pop(); // Get the last 2 operands\n              int o1 = opStack.pop();\n\n              int r = operate(s, o1, o2); // Perform operation\n              opStack.push(r); // Save result (operand) on stack\n\n          } else { // the next symbol is an oprands\n              opStack.push(Integer.parseInt(s)); // Save number as Integer\n          }\n      }\n      return opStack.pop(); // Return result (was saved on stack)\n  }\n\n  public static int operate(String op, int o1, int o2) {\n      if (op.equals(\"x\")) { // Multiply\n          return o1 * o2;\n      } else if (op.equals(\"/\")) {\n          return o1/o2;\n      } else if (op.equals(\"+\")) {\n          return o1 + o2;\n      }\n      else if (op.equals(\"-\")) {\n          return o1 - o2;\n      } else {\n          return 0;\n      }\n  }\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#stack-application-edsger-dijkstra-algorithm-for-fully-parenthesized-arithmetic-expression",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#stack-application-edsger-dijkstra-algorithm-for-fully-parenthesized-arithmetic-expression",
    "title": "Lecture 8 Stack",
    "section": "Stack Application: Edsger Dijkstra Algorithm for Fully Parenthesized Arithmetic Expression",
    "text": "Stack Application: Edsger Dijkstra Algorithm for Fully Parenthesized Arithmetic Expression\n\nProblem description:\n\nWe are given a fully parenthesized arithmetic expression using only x, /, +, and - operations.\nWrite an algorithm to evaluate expressions in this form.\nWe will need 2 stakcs:\n\nAn operand stack that stores the operands in the input, and\nAn operator stack that stores the operators in the input.\n\n\nAlgorithm:\n\nFind the first occurrence of a right parenthesis ): observe the last 2 operands and the last operation prior to the right parenthesis.\n\nThis guarantees the most inner () will be the first to be evaluated.\nThe result of an operation must be pushed on to operand stack.\n\nThen, we can reduce the parenthesis and find the next earliest occurrence of the right parenthesis.\nRepeat the steps until the input array is exhausted.\nThe left parenthesis ( does not convey and information.\n\nimport java.util.Stack;\npublic class Dijkstra2Stackalg {\n  public static Integer eval(String[] inp) {\n      Stack&lt;Integer&gt; operandStck = new Stack&lt;&gt;();\n      Stack&lt;String&gt; operatorStck = new Stack&lt;&gt;();\n      String s;\n\n      for (int i = 0; i &lt; inp.lengthl i++) {\n          s = inp[i];\n          if (s.equals(\"(\")) {\n              // do nothing\n          } else if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"x\") || s.equals(\"/\")) { // s is an operator\n              operatorStck.push(s);\n          } else if (s.equals(\")\")) { // compute the must inner ()\n              int o2 = operandStck.pop();\n              int o1 = operandStck.pop();\n              String op = operatorStck.pop();\n              int r = operate(op, o1, o2);\n              operandStck.psuh(r);\n          } else { // s is a number\n              operandStck.push(s);\n          }\n      }\n      return operandStck.pop();\n  }\n}"
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html",
    "href": "notes/cs171/14-Hashing/Hashing.html",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "",
    "text": "Dictionary or map is a data structure. &gt; Dictionary/map: aka. associative array is a data structure that consists of a collection of (key, value) pairs called an entry of a dictionary. &gt; - Note: the key and the value can be composite.\nUsage of a dictionary:\n\nThe dictionary data structure is used to store (key, value) pairs where the user can loop up (=search) a value using the key.\nTo support its usage, a dictionary must provide the following operations:\n\nsize(): return the number of entries stored inside this dictionary.\nput(key, value)L if key is found in the dictionary, it updates the value with value. Otherwise, it inserts (key, value) into the dictionary.\nget(key): return the corresponding value if key is found, and return null otherwise.\nremove(key): remove the dictionary entry containing key (and return the corresponding vaue if key is found).\n\nThe most frequently used operation is get(key), so fast lookup is required!\n\nThe Dictionary interface:\n\npublic interface Dictionary&lt;K,V&gt; {\n    public int size(); // return number of entires in the dictionary\n    public void put(K key, V value); // insert or update (key, value) pair\n    public V get(K key); // return value associated with key; \n                         // return null if not found\n    public V remove(K key); // remove entry with key and return corresponding value\n}\n\nWe can implement the dictionary data structure using:\n\nAn array\nA linked list\n\nFor simplicity, we will implement the dictionary using an array. To achieve it, we need to:\n\nDefinition of the Entry class to represent an entry in a dictionary.\nDefinition of a class to represent a dictionary using an array.\nImplement the (support) methods of the Dictionary interface.\n\nThe Entry class and the ArrayMap implementation:\n\npublic class ArrayMap&lt;K,V&gt; implements Dictionary&lt;K,V&gt; {\n    /* ---------------- Nested Entry class ---------------- */\n    private class Entry&lt;K,V&gt; {\n        private K key; // The key (to look up)\n        private V value; // the value (corresponding to the key)\n\n        public Entry(K k, V v) { // constructor\n            key = k;\n            value = v;\n        }\n\n        /** Accessor method fvor the key **/\n        public K getKey() {\n            return key;\n        }\n\n        /** Accessor method for the value **/\n        public V getValue() {\n            return value;\n        }\n\n        /** Mutator method for the value **/\n        public void setValue(V v) {\n            this.value = v;\n        }\n\n        @Override\n        public String toString() {\n            return \"(`\" + key + \"`, `\" + value + \"`)\"; \n        }\n    }\n    /* ---------------- End of nested Entry class ---------------- */\n\n    Entry&lt;K,V&gt;[] entry; // Dictionary\n    int nEntries; // number of entries in the dictionary\n\n    public ArrayMap(int N) { // Constructor\n        entry = new Entry[N];\n        nEntries = 0;\n    }\n\n    @Override\n    public int size() {\n        return nEntries;\n    }\n\n    @Override\n    public void put(K k, V v) {\n        for (int i = 0; i &lt; nEntries; i++) {\n            if (entry[i].getkey().equals(k)) {\n                // Found\n                entry[i].setValue(v); // update the value\n                return;\n            }\n        }\n        // Key not found\n        entry[nEntries] = new Entry&lt;K,V&gt;(k, v); // insert (k,v)\n        nEntries++;\n    }\n\n    @Override\n    public V get(K k) {\n        for (int i = 0; i &lt; nEntries; i++) {\n            if (entry[i].getKey().equals(k)) {\n                // Found\n                return entry[i].getValue();\n            }\n        }\n        // Not found\n        return null;\n    }\n\n    @Override\n    public V remove(K k) {\n        boolean found = false; // Indicate key not found\n        int loc = -1; // contains index of key\n        V ret = null; // contains the return value\n\n        for (int i = 0; i &lt; nEntires; i++) {\n            if (entry[i].getKey().equals(k)) {\n                found = true; // indicates key k was found\n                loc = i; // remember the index of the entry\n                break;\n            }\n        }\n\n        if (found) {\n            // Key found\n            ret = entry[loc].getValue(); // update return value\n            for (int i = loc + 1; i &lt; nEntries; i++) {\n                // delete entry [loc]\n                entry[i-1] = entry[i]; // shift array\n            }\n            nEntries--;\n        }\n        return ret;\n    }\n}\n\nProblems with the ArrayMap implementation:\n\nA dictionary is used to look up information (=value) for a given key.\nThe loop up operation get() is \\(\\mathcal{O}(n)\\).\n\nCan we do better than \\(\\mathcal{O}(n)\\)?\n\nYes, we can sort the array and use binary search to reduce the runtime to \\(\\mathcal{O}(\\log n)\\).\n\nCan we do better than \\(\\mathcal{O}(\\log n)\\)?\n\nYes, we can use hashing to reduce the runtime to \\(\\mathcal{O}(1)\\)."
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html#the-dictionary-data-structure",
    "href": "notes/cs171/14-Hashing/Hashing.html#the-dictionary-data-structure",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "",
    "text": "Dictionary or map is a data structure. &gt; Dictionary/map: aka. associative array is a data structure that consists of a collection of (key, value) pairs called an entry of a dictionary. &gt; - Note: the key and the value can be composite.\nUsage of a dictionary:\n\nThe dictionary data structure is used to store (key, value) pairs where the user can loop up (=search) a value using the key.\nTo support its usage, a dictionary must provide the following operations:\n\nsize(): return the number of entries stored inside this dictionary.\nput(key, value)L if key is found in the dictionary, it updates the value with value. Otherwise, it inserts (key, value) into the dictionary.\nget(key): return the corresponding value if key is found, and return null otherwise.\nremove(key): remove the dictionary entry containing key (and return the corresponding vaue if key is found).\n\nThe most frequently used operation is get(key), so fast lookup is required!\n\nThe Dictionary interface:\n\npublic interface Dictionary&lt;K,V&gt; {\n    public int size(); // return number of entires in the dictionary\n    public void put(K key, V value); // insert or update (key, value) pair\n    public V get(K key); // return value associated with key; \n                         // return null if not found\n    public V remove(K key); // remove entry with key and return corresponding value\n}\n\nWe can implement the dictionary data structure using:\n\nAn array\nA linked list\n\nFor simplicity, we will implement the dictionary using an array. To achieve it, we need to:\n\nDefinition of the Entry class to represent an entry in a dictionary.\nDefinition of a class to represent a dictionary using an array.\nImplement the (support) methods of the Dictionary interface.\n\nThe Entry class and the ArrayMap implementation:\n\npublic class ArrayMap&lt;K,V&gt; implements Dictionary&lt;K,V&gt; {\n    /* ---------------- Nested Entry class ---------------- */\n    private class Entry&lt;K,V&gt; {\n        private K key; // The key (to look up)\n        private V value; // the value (corresponding to the key)\n\n        public Entry(K k, V v) { // constructor\n            key = k;\n            value = v;\n        }\n\n        /** Accessor method fvor the key **/\n        public K getKey() {\n            return key;\n        }\n\n        /** Accessor method for the value **/\n        public V getValue() {\n            return value;\n        }\n\n        /** Mutator method for the value **/\n        public void setValue(V v) {\n            this.value = v;\n        }\n\n        @Override\n        public String toString() {\n            return \"(`\" + key + \"`, `\" + value + \"`)\"; \n        }\n    }\n    /* ---------------- End of nested Entry class ---------------- */\n\n    Entry&lt;K,V&gt;[] entry; // Dictionary\n    int nEntries; // number of entries in the dictionary\n\n    public ArrayMap(int N) { // Constructor\n        entry = new Entry[N];\n        nEntries = 0;\n    }\n\n    @Override\n    public int size() {\n        return nEntries;\n    }\n\n    @Override\n    public void put(K k, V v) {\n        for (int i = 0; i &lt; nEntries; i++) {\n            if (entry[i].getkey().equals(k)) {\n                // Found\n                entry[i].setValue(v); // update the value\n                return;\n            }\n        }\n        // Key not found\n        entry[nEntries] = new Entry&lt;K,V&gt;(k, v); // insert (k,v)\n        nEntries++;\n    }\n\n    @Override\n    public V get(K k) {\n        for (int i = 0; i &lt; nEntries; i++) {\n            if (entry[i].getKey().equals(k)) {\n                // Found\n                return entry[i].getValue();\n            }\n        }\n        // Not found\n        return null;\n    }\n\n    @Override\n    public V remove(K k) {\n        boolean found = false; // Indicate key not found\n        int loc = -1; // contains index of key\n        V ret = null; // contains the return value\n\n        for (int i = 0; i &lt; nEntires; i++) {\n            if (entry[i].getKey().equals(k)) {\n                found = true; // indicates key k was found\n                loc = i; // remember the index of the entry\n                break;\n            }\n        }\n\n        if (found) {\n            // Key found\n            ret = entry[loc].getValue(); // update return value\n            for (int i = loc + 1; i &lt; nEntries; i++) {\n                // delete entry [loc]\n                entry[i-1] = entry[i]; // shift array\n            }\n            nEntries--;\n        }\n        return ret;\n    }\n}\n\nProblems with the ArrayMap implementation:\n\nA dictionary is used to look up information (=value) for a given key.\nThe loop up operation get() is \\(\\mathcal{O}(n)\\).\n\nCan we do better than \\(\\mathcal{O}(n)\\)?\n\nYes, we can sort the array and use binary search to reduce the runtime to \\(\\mathcal{O}(\\log n)\\).\n\nCan we do better than \\(\\mathcal{O}(\\log n)\\)?\n\nYes, we can use hashing to reduce the runtime to \\(\\mathcal{O}(1)\\)."
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html#the-hash-function",
    "href": "notes/cs171/14-Hashing/Hashing.html#the-hash-function",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "The Hash Function",
    "text": "The Hash Function\n\nInsight on how to improve the search performance of arrays.\n\nFact on arrays:\n\nArray access is very fast if access uses an array index.\n\nFact on dictionaries:\n\nEntries in a dictionary are looked up using its key.\n\nThe problem with the ArrayMap implementation of the dictionary is that entries of the dictionary are stored using an index that is not related to the key.\nTo improve the search operation for a dictionary stored in an array, we need to find a way to relate (=map) the key k to an index h of the array:\nh = hashFunction(k)\nThis way of storing data into an array is called hashing.\n\nHashing functions H():\n\nHash function is a function that maps a key k to a number h in the range [0, M-1], where M = length of the array. That is, \\(h=H(k)\\), where \\(h\\in[0,\\cdots,M-1]\\).\n\nH() is consistent: always gives the same answer for a given key.\nH() is uniform: the function values are distributed evenly across [0...M-1].\n\nA hash function is usually specified as the composition of 2 functions: \\(H(k)=H_2(H_1(k))\\), where\n\n\\(H_1(k)\\) is the hash code function that returns the integer value of the key k.\n\\(H_2(x)\\) is a compression function that maps a value \\(x\\) uniformly to the range \\([0, M-1]\\).\n\n\nThe hash code of a key:\n\nFact: all data inside a computer is stored as abinary number.\nThe Object class in Java contains a hashCode() method that returns the data stored in the Object as an integer.\nWe can use the hashCode() method as our \\(H_1(k)\\) function.\n\nThe compression function \\(H_2(x)\\)\n\nNotice from the previous discussion on the hash code \\(H_1(k)\\): \\(H_1(k)\\) uses the data stored in the key k to compute (deterministically) a hash code value.\nThe compression function \\(H_2(x)\\) has two purposes:\n\nMake sure that the return value is in the range \\([0, M-1]\\). (where \\(M\\) is the length of the array).\nScatter/randomize the input value \\(x=H_1(k)\\), so that the value \\(H_2(x)\\) is evenly/uniformly distributed over the range \\([0, M-1]\\).\n\nWhy do we use uniform randomization?\n\nThe array element used to stroe the diction entry is array index = H(k) = H2(H1(k)).\nUniform randomization will minimize the likelihoo/chance that 2 different keys being hashed to the same value (=array index) (a.k.a. collision).\n\nA commonly used compression function is the Multiply Add Divide (MAD) function:\nH2(x) = ( (ax + b) % p ) % M,   where p = some prime number\n           ^^^^^^^^^^^^\n            randomizes\n\nIn the MAD function, a and b are random numbers, and p is a prime number.\nIn the examples of this course, we will use p = 109345121 (a prime number), a = 123 and a = 456.\nNote: p must be greater than M (i.e., p &gt; M), otherwise, we will not use the full capacity of the array."
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html#hash-table",
    "href": "notes/cs171/14-Hashing/Hashing.html#hash-table",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "Hash Table",
    "text": "Hash Table\n\nTerminologies:\n\nHash function H(): maps a key k to an integer in the range [0, M-1]. H(k) = integer in [0, M-1].\nHash value h: the value returned by the hash function H(): h = H(k).\nBucket: the array element used to store an entry of the dictionary.\nCollision: A collision occurs when 2 different keys k1 and k2 have the same hash value. h1≠h2 but H(k1)=H(k2).\n\nIf there are n entries in a hash table of size M, how likely is it that 2 entries hash into the same bucket? \\[\n\\begin{aligned}\n\\mathbf{P}(\\text{all }n\\text{ entries use different buckets}) &= \\dfrac{M(M-1)\\cdots (M-n+1)}{M^n} \\\\\n&=\\dfrac{M!}{M^n(M-n)!}\\\\\n\\mathbf{P}(\\text{2 entries use the same buckt})&=1-\\dfrac{M!}{M^n(M-n)!}.\n\\end{aligned}\n\\]\n\nThere are 2 techniques to handle collision in hashing:\n\nClosed addressing (a.k.a. Separable Chaining):\n\nEntries are always stored in their hash bucket.\nEach bucket of the hash table is organized as a linked list.\n\n\nOpen addressing:\n\nEntries are stored in a different bucket than their hash buckets.\nA rehash algorithm is used to find an empty bucket.\n\n\n\n\n\nClosed Addressing (Separate Chaining)\n\nPreviously, we used the Entry&lt;K,V&gt; class in the ArrayMapo&lt;K,V&gt; implementation to store the dictionary entries.\n\nIn order to support separate chaining, the Entry&lt;K,V&gt; class must be modified to support a linked list.\n\npublic class HashTableSC&lt;K,V&gt; implements Dictionary&lt;K,V&gt; {\n  /* ---------------- Nested Entry class ---------------- */\n  private class Entry&lt;K,V&gt; {\n      private K key; // key\n      private V value; // value\n      private Entry&lt;K,V&gt; next; // link to create a linked list\n\n      public Entry(K k, V V) { // constructor\n          key = k;\n          value = v;\n      }\n      /** Accessor method fvor the key **/\n      public K getKey() {\n          return key;\n      }\n      /** Accessor method for the value **/\n      public V getValue() {\n          return value;\n      }\n      /** Mutator method for the value **/\n      public void setValue(V v) {\n          this.value = v;\n      }\n      @Override\n      public String toString() {\n          return \"(`\" + key + \"`, `\" + value + \"`)\"; \n      }\n  }\n  /* ---------------- End of nested Entry class ---------------- */\n\n  public Entry&lt;K,V&gt;[] bucket; // The hash table\n  public int capacity; // capacity = bucket.length\n  int NItems; // number of entries in the hash table\n\n  // MAD formula: (Math.abs(a * HashCode + b) % p) % M\n  public int MAD_p; // prime number in the MAD alg\n  public int MAD_a; // multiplier in the MAD alg\n  public int MAD_b; // offset in the MAD alg\n\n  public HashTableSC(int M) { // create a hash table of size M\n      bucket = (Entry[]) new Entry[M]; // create hash table of size M\n      capacity = bucket.length; // capacity of has table\n      NItems = 0; // number of entries in the hash table\n\n      // Initialize MAD parameters\n      MAD_p = 109345121; // prime number\n      MAD_a = 123; // multiplier\n      MAD_b = 456; // offset\n  }\n\n  /** Hash function H(k) **/\n  public int hashValue(K key) {\n      int x = key.hashCode(); // hash code of the key\n      return (Math.abs(x * MAD_a + MAD_b) % MAD_p) % capacity;\n  }\n\n  /* ---------------------------------------------\n  The help method findEntry(k): find the Entry containing key in the hash table\n  return: Entry object containing key if found\n  return: null if not found\n  --------------------------------------------- */\n  public Entry findEntry(K k) {\n      int hashIdx = hashValue(k); // get hash index using key k\n      Entry&lt;K,V&gt; curr = bucket[hashIdx]; // curr = first of linked list\n\n      while (curr != null) {\n          if (curr.getKey().equals(k)) {\n              return curr;\n          }\n          curr = curr.next;\n      }\n      return null; // not found\n  }\n\n  @Override\n  public int size() {\n      return NItems;\n  }\n\n  @Override\n  public void put(K k, V v) {\n      int hashIdx = hashValue(k);\n      Entry&lt;K,V&gt; h = findEntry(k);\n      if (h != null) {\n          h.setValue(v); // update value with v\n      } else {\n          // Add newEntry as first element in the list at bucket[hashIdx]\n          Entry&lt;K,V&gt; newEntry = new Entry&lt;&gt;(k, v); // make new entry\n          newEntry.next = bucket[hashIdx]; // point to the first bucket\n          bucket[hashIdx] = newEntry; // make newEntry the first bucket\n          NItems++; // increment number of entries\n      }\n  }\n\n  @Override\n  public V get(K k) {\n      Entry&lt;K, V&gt; h = findEntry(k);\n      if (h != null) {\n          return h.getValue();\n      } else {\n          return null;\n      }\n  }\n\n  @Override\n  public V remove(K k) {\n      int hashIdx = hashValue(k);\n      // General case delete from linked list\n      Entry&lt;K,V&gt; previous = bucket[hashIdx];\n      Entry&lt;K,V&gt; current = bucket[hashIdx];\n\n      while (current != null && !current.getValue().equals(k)) {\n          previous = current;\n          current = current.next;\n      }\n\n      if (current != null) { // found\n          previous.next = current.next; // unlink current\n          NItems--; // decrement number of entries\n          return current.getValue();\n      } \n      return null; // not found\n  }\n}\nRuntime analysis:\n\nConsider a hash table using separate chaining. Due to randomization of the hash value,\n\nSome entries in the hash table has no keys\nSome entries in the hash table has exactly 1 key.\nSome entries in the hash table has more than 1 key.\n\nOperations on a hash table always uses the hash value. The hash value will select one specific hash bucket.\n\nThe search key will be:\n\nFound in this hash bucket, or\nNot found in this hash bucket.\n\n\nTherefore, operations on a hash table will always examine all keys in one search bucket.\nTherefore, the running time of operations on a hash table is equal to the number of entries stored inside one bucket in the hash table.\n\nProblem: how many entries will be stored inside 1 bucket?\nFact: A search key that has hash value k is stored in the bucket k.\nTherefore, number of entries in bucket k is the number of keys where H(key) = k.\nNow, let’s estimate the number of entries stored in a bucket.\nBy the uniformity assumption, the random hash value H(key) is uniformly distributed over the range [0, M-1]. Then, each outcome is equally likely with probability of 1/M.\nSuppose there are a total of n items/entries hashed and stored in the hash table. According to the theory of probability, the number of items/entries in any bucket has a binomial probability distribution of \\(\\mathbf{BIN}\\left(n,p=\\dfrac{1}{M}\\right)\\).\nThen, the average number of entries in 1 bucket is \\(\\dfrac{n}{M}\\). So, the average running time for hash operations is \\(\\dfrac{n}{M}\\sim\\mathcal{O}(n)\\).\n\n\n\n\n\nOpen Addressing\n\nClosed addressing vs Open addressing:\n\nClosed addressing:\n\nIn closed addressing, each key is always stored in the hash bucket where the key is hashed to.\nClose addressing must use some data structure (e.g. linked list) to store multiple entries in the same bucket.\n\nOpen addressing:\n\nIn open addressing, each hash bucket will store at most one hash table entry.\nIn open addressing, a key may be stored in different bucket than where they key was hashed to.\nEntries used in open addressing:\n\nSince in open addressing, each hash bucket will store at most one hash table entry, the entries stored in open address do not have a link variable.\nTherefore, the Entry&lt;K,V&gt; class used in open addressing is different from the Entry&lt;K,V&gt; class used in closed addressing. In fact, we can use the Entry&lt;K,V&gt; defined the ArrayMap&lt;K,V&gt; implementation.\n\n\n\nCollision resolution in Open Addressing:\n\nIf a key is hashed to a bucket that is already occupied, we need to find another bucket to store the key. This process will be completed with an insert algorithm.\nThe insert algorithm will start at the hash index and find the next variable hash bucket that can be used to store the key.\nThe procedure to find the next available hash bucket is called rehashing.\n\nNote: rehashing is not random but deterministic (=computable).\n\n\nCommonly used Rehashing Algorithms to Resolve Collision in Open Addressing:\n\nLinear Probing: in linear probing, the hash table is searched sequentially starting from the hash index value.\n\nIn other words, the rehash function is Rehash(key) = (h + i)%M, where h = H(key) and i = 1, 2,...\n\nQuadratic Probing: uses the following rehash function: Rehash(key) = (h + i^2)%M, where h = H(key) and i = 1, 2,...\nDouble hashing: uses the following rehash function: Rehash(key) = (h + i*H2(key))%M, where h = H(key), h' = H'(key) is a second hash function, and i = 1, 2,...\n\nThe code for linear probing without remove():\n\npublic class HashTableLP&lt;K,V&gt; {\n    /* ---------------- Nested Entry class ---------------- */\n    private class Entry&lt;K,V&gt; {\n        private K key;   // The key (to loop up)\n        private V value; // The value (corresponding to the key)\n        public Entry(K k, V v) { // Constructor\n            key = k;\n            value = v;\n        }\n        public K getKey() { // Accessor method for the key\n            return key;\n        }\n        public V getValue() {  // Accessor method for the value\n            return value;\n        }\n        public void setValue(V value) {         // Mutator method for the value\n            this.value = value;\n        }\n        public String toString() {\n            return \"(\" + key + \",\" + value + \")\";\n        }\n    }\n    /* ---------------- End of nested Entry class ---------------- */\n\n    public Entry&lt;K,V&gt;[] bucket; // The Hash table\n    public int capacity;        // capacity == bucket.length\n    int    NItems;              // # items in hash table\n    // MAD formula: ( Math.abs(a * HashCode + b) % p ) % M\n    public int MAD_p;           // Prime number in the Multiply Add Divide alg\n    public int MAD_a;           // Multiplier   in the Multiply Add Divide alg\n    public int MAD_b;           // Offset       in the Multiply Add Divide alg\n\n    // Constructor\n    public HashTableLP(int M) {  // Create a hash table of size M\n        bucket = (Entry[]) new Entry[M]; // Create a hash table of size M\n        capacity = bucket.length;        // Capacity of this hash table\n        NItems = 0;                      // # items in hash table\n\n        MAD_p = 109345121;               // We pick this prime number...\n        MAD_a = 123;                     // a = non-zero random number\n        MAD_b = 456;                     // b = random number\n    }\n\n    // The hash function for the hash table\n    public int hashValue(K key) {\n        int x = key.hashCode(); // Uses Object.hashCode()\n        return ((Math.abs(x*MAD_a + MAD_b) % MAD_p) % capacity);\n    }\n    public int size() {\n        return NItems;\n    }\n\n    public void put(K k, V v) {\n        int hashIdx = hashValue(k); // find the hash index for key k\n        int i = hashIdx;\n        do {\n            if (bucket[i] == null) { // is entry empty?\n                bucket[i] = new Entry&lt;K,V&gt;(k, v);\n                return;\n            } else if (entry[i].getKey().equals(k)) { // is entry k?\n                entry[i].setValue(v); // update value\n                return;\n            } \n            i = (i + 1) % capacity; // rehash\n        } while (i != hashIdx); // all entires searched!\n        System.out.println(\"Full\");\n    }\n\n    public V get(K k) {\n        int hashIdx = hashValue(k); // find the hash index for key k\n        int i = hashIdx;\n        do {\n            if (bucket[i] == null) { // is entry empty?\n                return null;\n            } else if (entry[i].getKey().equals(k)) { // is entry k?\n                return entry[i].getValue(); // return value\n            } \n            i = (i + 1) % capacity; // rehash\n        } while (i != hashIdx); // all entires searched!\n        return null; // not found\n    }\n}\n\nNow, let’s consider the remove() method. If we remove the entry stored in bucket[i], then we will not be able to find the entry stored in bucket[i+1].\n\nTherefore, we need to move the entry stored in bucket[i+1] to bucket[i].\nHowever, if we move the entry stored in bucket[i+1] to bucket[i], then we will not be able to find the entry stored in bucket[i+2].\nThat means, instead of simply moving the entry stored in bucket[i+1] to bucket[i], we need alternative method to solve this problem.\n\nTo solve the deletion problem, a hash table using open addressing uses a special entry called AVAILABLE: java     public Entry&lt;K,V&gt; AVAILABLE = new Entry&lt;&gt;(null, null);\n\nWhen an existing entry in the hash table is removed, the entry is replaced by the AVAILABLE entry.\nWhen we are searching for key k, then\n\nAVAILABLE must be treated as an empty bucket (i.e., it does not contain any key).\nThe rehash algorithm must continue with the next search location.\n\npublic class HashTableLP&lt;K,V&gt; implements Dictionary&lt;K,V&gt; {\n/* ---------------- Nested Entry class ---------------- */\nprivate class Entry&lt;K,V&gt; {\n    private K key;   // The key (to loop up)\n    private V value; // The value (corresponding to the key)\n    public Entry(K k, V v) { // Constructor\n        key = k;\n        value = v;\n    }\n    public K getKey() { // Accessor method for the key\n        return key;\n    }\n    public V getValue() {  // Accessor method for the value\n        return value;\n    }\n    public void setValue(V value) {         // Mutator method for the value\n        this.value = value;\n    }\n    public String toString() {\n        return \"(\" + key + \",\" + value + \")\";\n    }\n}\n/* ---------------- End of nested Entry class ---------------- */\n\npublic Entry&lt;K,V&gt;[] bucket; // The Hash table\npublic int capacity;        // capacity == bucket.length\nint    NItems;              // # items in hash table\n// MAD formula: ( Math.abs(a * HashCode + b) % p ) % M\npublic int MAD_p;           // Prime number in the Multiply Add Divide alg\npublic int MAD_a;           // Multiplier   in the Multiply Add Divide alg\npublic int MAD_b;           // Offset       in the Multiply Add Divide alg\n\npublic Entry&lt;K,V&gt; AVAILABLE = new Entry&lt;&gt;(null, null); // special entry for remove()\n\n// Constructor\npublic HashTableLP(int M) {  // Create a hash table of size M\n    bucket = (Entry[]) new Entry[M]; // Create a hash table of size M\n    capacity = bucket.length;        // Capacity of this hash table\n    NItems = 0;                      // # items in hash table\n\n    MAD_p = 109345121;               // We pick this prime number...\n    MAD_a = 123;                     // a = non-zero random number\n    MAD_b = 456;                     // b = random number\n}\n\n// The hash function for the hash table\npublic int hashValue(K key) {\n    int x = key.hashCode(); // Uses Object.hashCode()\n    return ((Math.abs(x*MAD_a + MAD_b) % MAD_p) % capacity);\n}\n\n@Override\npublic int size() {\n    return NItems;\n}\n\n@Override\npublic void put(K k, V v) {\n    int hashIdx = hashValue(k); // find the hash index for key k\n    int i = hashIdx;\n    int firstAvail = -1; // -1 means: no AVAILABLE entry found\n\n    do { // search for key k\n        if (bucket[i] == null) { // is entry empty?\n            if (firstAvail = -1 ) { // No AVAILABLE entry found\n                bucket[i] = new Entry&lt;K,V&gt;(k, v);\n                // insert (k,v) in this empty bucket\n            } else { // AVAILABLE entry found\n                bucket[firstAvail] = new Entry&lt;K,V&gt;(k, v);\n                // insert (k,v) in the first AVAILABLE bucket\n            }\n            return;\n        } else if (bucket[i] == AVAILABLE) {\n            if (firstAvail == -1) {\n                firstAvail = i; // remember the first AVAILABLE entry\n            }\n        } else if (entry[i].getKey().equals(k)) { // is entry k?\n            entry[i].setValue(v); // update value\n            return;\n        } \n        i = (i + 1) % capacity; // rehash\n    } while (i != hashIdx); // all entires searched!\n\n    if (firstAvail == -1) {\n        System.out.println(\"Full\");\n    } else {\n        bucket[firatAvail] = new Entry&lt;&gt;(k,v);\n    }\n}\n\n@Override\npublic V get(K k) {\n    int hashIdx = hashValue(k); // find the hash index for key k\n    int i = hashIdx;\n    do {\n        if (bucket[i] == null) { // is entry empty?\n            return null;\n        } else if (bucket[i] == AVAILABLE) {\n            // Do NOT Test bucket[i]\n            // continue\n        } else if (entry[i].getKey().equals(k)) { // is entry k?\n            return entry[i].getValue(); // return value\n        } \n        i = (i + 1) % capacity; // rehash\n    } while (i != hashIdx); // all entires searched!\n    return null; // not found\n}\n\n@Override\npublic V remove(K k) {\n    int hashIdx = hashValue(k);\n    int i = hashIdx;\n\n    do {\n        if (bucket[i] == null) { // Is bucket empty?\n            return null; // Not found\n        } else if (bucket[i] == AVAILABLE) {\n            // Do NOT Test bucket[i]\n            // continue\n        }  else if (bucket[i].getKey().equals(k)) { // does bucket contain k?\n            V retVal = bucekt[i].getValue();\n            bucket[i] = AVAILABLE; // mark as deleted\n            return retVal;\n        }\n        i = (i + 1) % capacity; // rehash\n    } while (i != hashIdx); // all entires searched!\n    return null; // not found\n}\n}\n\nClustering in Learning Hashing:\n\nSuppose the hash table currently stores the entries as follows:\n            0   1   2   3   4   5   6   7   8   9  \nentry[] = |   | A | B | C | D | E | F | G | H |   | \n\nThen, if we want to insert a key k with a hash value in the range [1...9]m we will have to store it in the bucket 9.\nThis is called clustering.\n\nTo alleviate clustering, other rehashing methods can be used:\n\nQuadratic Probing\nDouble hashing.\n\n\n\n\n\nRunning Time Analysis\n\nStrength and Weakness of a Hash Table\n\nA hash table is fast when entries are not clustered.\nIn this case, the running time of operations such as get(), pu() and remove() is \\(\\mathcal{O}(1)\\).\n\nThe search will find the key immediately in the hash bucket.\nOr else, the search will terminate in the next step because it finds an empty (null) bucket.\n\nA hash table is slower when entries are clustered. In those cases, we need more comparison operations.\n\nWorse case running time of hashing with linear probing: when the hash table is full.\n\nThen, get(), pu(), and remove() may need to scan the entire hash table to find the entry.\nTherefore, worse case running time of linear probing is n/2: The scan will examine approximately half of all the entries.\n\nAverage case running time analysis of linear probing:\n\nConsider the get() algorithm using linear probing. The get() method will return when it find\n\nan empty bucket, or\nthe key k\n\nConsider the put() algorithm using linear probing. The put() method will return when it find\n\nan empty bucket, or\nthe key k\n\nConsider the remove() algorithm using linear probing. The remove() method will return when it find\n\nan empty bucket, or\nthe key k\n\nSimplifying assumption: to keep the running time analysis simple, we will assume that where are no AVAILABLE entries in the hash table.\nFrom the observation of get(), put(), and remove() algorithms:\n\nThe running time of them depends on the number of entries we need to check in order to find the key k or an empty bucket.\nSo, the worse case running time is when the search ends by finding an empty bucket (takes longer time).\nTherefore, average running time of get(), put(), and remove() = average number of compare operations to find an empty bucket.\n\n\nLoad factor and the probability of finding an empty bucket. &gt; Load factor: a.k.a. occupancy level is defined as \\[\\alpha=\\dfrac{\\text{number of entries in hash table}}{\\text{size of the hash table}}=\\dfrac{n}{M}.\\] &gt; - The load factor \\(\\alpha\\) is a measure of how full the hash table is.\n\nThen, the probability (=likelihood) that a hash bucket is occuped is \\[\\begin{aligned}\\mathbf{P}(\\text{bucket }i\\text{ is occupied})&=\\dfrac{\\text{number of entries in the hash table}}{\\text{total number of buckets in the hash table}}\\\\&=\\alpha.\\end{aligned}\\]\nSo, the probability (=likelihood) that a hash bucket is empty is \\(\\mathbf{P}(\\text{buket }i\\text{ is empty})=1-\\alpha\\).\n\nThe average running time of get(), put(), and remove() is found by computing:\n\nHow often (frequent) do we need to check 1 entry to find an empty slot (=\\(f_1\\))? How many operations did we perform in this case? (=\\(c_1\\))\nHow often (frequent) do we need to check 2 entry to find an empty slot (=\\(f_2\\))? How many operations did we perform in this case? (=\\(c_2\\))\n…\nThe average running time of get(), put(), and remove() is equal to \\[\\text{Average running time}=f_1c_1+f_2c_2+f_3c_3+\\cdots\\]\n\nHow often do we need to check 1 entry to find an empty slot?\n\nThe probability of finding a bucket to be empty = \\(1-\\alpha\\).\nWe check 1 entry (=the hash bucekt) and fids an empty bucket. \\[\n\\mathbf{P}(\\text{check 1 bucket to find an empty bucket})=1-\\alpha=f_1\\\\\n\\text{number of check operations performed} = 1=c_1\n\\]\n\nSimilarly, in the case of checking 2 entries to find an empty bucket, we have: \\[\n\\mathbf{P}(\\text{check 2 bucket to find an empty bucket})=\\alpha(1-\\alpha=)f_2\\\\\n\\text{number of check operations performed} = 2=c_2\n\\]\nSo, we know the average running time of get(), put(), and remove() is equal to \\[\n\\begin{aligned}\\text{Average running time}&=f_1c_1+f_2c_2+\\cdots+f_nc_n\\\\\n&=(1-\\alpha)\\cdot1+\\alpha(1-\\alpha)\\cdot2+\\alpha^2(1-\\alpha)\\cdot3+\\cdots\\\\\n&=(1-\\alpha)[1+2\\alpha^1+3\\alpha^2+4\\alpha^3+\\cdots]\n\\end{aligned}\n\\]\n\nSuppose \\[S=1+2\\alpha^1+3\\alpha^2+4\\alpha^3+\\cdots.\\] To compute the sum, we used MATLAB ```matlab syms a k assume(a &gt; 0 & a &lt; 1) symsum((k+1)*(a^k), k, 0, inf)\n\n\n\nans = 1/(a - 1)^2 ```\n\n\n\nSo, the average running time of get(), put(), and remove() is equal to \\[(1-\\alpha)\\cdot\\dfrac{1}{(1-\\alpha)^2}=\\dfrac{1}{1-\\alpha}.\\]\n\nSummary:\n\n\\(\\alpha\\) = the load factor or occupancy level.\nThe probability (=likelihood) of finding a bucket to be empty = \\(1-\\alpha\\).\nThe average runtime of get(), put(), and remove() is the average number of compare operations performed to find an empty bucket. This quantity is equal to \\(\\dfrac{1}{1-\\alpha}\\).\nExample: If \\(\\alpha=10\\%\\), then (because 90% of the time we find an empty bucket), average number bucekts searched is 1/(1-0.1) = 1/0.9 ~= 1.1."
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html#double-hashing",
    "href": "notes/cs171/14-Hashing/Hashing.html#double-hashing",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "Double Hashing",
    "text": "Double Hashing\n\nConsequence of increasing/decreasing the hash table size:\n\nDue to the dependency of the hash function on the array size M, we have the following unfortunate consequence: Changing the array size will also change the hash function.\nThis means: the entries stored using the old hash function cannot be found using the new hash function.\nIn other words, when we increase/decrease the hash table size, we must rehash all the entries using the new hash function.\n\nNaïve way to increase/decrease the hash table size.\n\nBecause the hash function changes with the hash table size, we must rehash all the keys and insert them into the new hash table.\nA naïve way to do this is to create a new hash table with the new size, and then insert all the keys into the new hash table.\n\npublic void doubleHashTable() {\n  Entry[] oldBucket = bucket; // save the old hash table\n\n  // Double the size of the bucket\n  bucket = (Entry[]) new Entry[2 * oldBucket.length];\n  capacity = 2 * oldBucket.length;\n\n  // Rehash all the entries in the old hash table\n  for (int i = 0; i &lt; oldBucket.length; i++) {\n      if (oldBucket[i] != null && oldBucket[i] != AVAILABLE) {\n          this.put(oldBucket[i].getKey(), oldBucket[i].getValue());\n      }\n  }\n}"
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "",
    "text": "Goal of sorting: rearrange \\(N\\) items such that their keys are in ascending (increasing) order.\nSorting algorithms are based on the following operations:\n\nCompare: compare two items and determine their relative order.\nExchange: swap two items.\n\nThe preimitive operation in sorting is the comparison.\nComparing items: the Java Comparable interface:\n\nSorting requires that 2 items can be compared.\nJava defines the Comparable&lt;T&gt; interface to represent this requirement:\npublic Interface Comparable&lt;T&gt; {\n    public int  compareTo(T o);\n}\nClass that implements Comparable&lt;T&gt; are comparable classes, and they must implement the compareTo() method.\nRequirement of the compareTo() method:\n\na.compareTo(b) returns a negative value if a is less than b.\na.compareTo(b) returns zero if a is equal to b.\na.compareTo(b) returns a positive value if a is greater than b.\n\n\nExchanging two items (objects) in an array: java     public static void exch(DataType[] a, int i, int j) {         DataType help;         help = a[i];         a[i] = a[j];         a[j] = help;     }\n\nThe exch() method will only work on objects of the type DataType.\nWe can define a generic (parameterized) exch() so that it will only work on subclasses of Comparable&lt;T&gt;:\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void exch(T[] a, int i, int j) {\n    T help;\n\n    help = a[i];\n    a[i] = a[j];\n    a[j] = help;\n}"
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#introduction-to-sorting",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#introduction-to-sorting",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "",
    "text": "Goal of sorting: rearrange \\(N\\) items such that their keys are in ascending (increasing) order.\nSorting algorithms are based on the following operations:\n\nCompare: compare two items and determine their relative order.\nExchange: swap two items.\n\nThe preimitive operation in sorting is the comparison.\nComparing items: the Java Comparable interface:\n\nSorting requires that 2 items can be compared.\nJava defines the Comparable&lt;T&gt; interface to represent this requirement:\npublic Interface Comparable&lt;T&gt; {\n    public int  compareTo(T o);\n}\nClass that implements Comparable&lt;T&gt; are comparable classes, and they must implement the compareTo() method.\nRequirement of the compareTo() method:\n\na.compareTo(b) returns a negative value if a is less than b.\na.compareTo(b) returns zero if a is equal to b.\na.compareTo(b) returns a positive value if a is greater than b.\n\n\nExchanging two items (objects) in an array: java     public static void exch(DataType[] a, int i, int j) {         DataType help;         help = a[i];         a[i] = a[j];         a[j] = help;     }\n\nThe exch() method will only work on objects of the type DataType.\nWe can define a generic (parameterized) exch() so that it will only work on subclasses of Comparable&lt;T&gt;:\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void exch(T[] a, int i, int j) {\n    T help;\n\n    help = a[i];\n    a[i] = a[j];\n    a[j] = help;\n}"
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#selection-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#selection-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Selection Sort",
    "text": "Selection Sort\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void selectionSort(T[] list) {\n    for (int i = 0; i &lt; list.length-1; i++) {\n        // Find the minimum in the list[i..list.length-1]\n        T min = list[i]; // Assume first element is min\n        int minIndex = i; // index where min is found\n\n        for (int k = minIndex+1; k &lt; list.length; k++) {\n            if (list[k].compareTo(min) &lt; 0) { // compare list[k] and min\n                min = list[k]; // update min value\n                minIndex = k; // update min index\n            }\n        }\n\n        // Swap list[i] with list[minIndex] if necessary\n        if (minIndex != i) {\n            exch(list, i, minIndex);\n        }\n    }\n}\n\nRuntime analysis:\n\nThe algorithm can be simplified as follows:\nfor (int i = 0; i &lt; n-1; i++) {\n    for (int k = i + 1; k &lt; n; k++) {\n        doPrimitive();\n    }\n}\n\n\n\ni=\n0\n1\n2\n…\nn-3\nn-2\n\n\n\n\nk=\n1\n2\n3\n…\nn-2\nn-1\n\n\nk=\n2\n3\n4\n…\nn-1\n\n\n\n…\n…\n…\n…\n\n\n\n\n\nk=\nn-2\nn-1\n\n\n\n\n\n\nk=\nn-1\n\n\n\n\n\n\n\n\n\nSo, number of iterations is \\((n-1)+(n-2)+(n-3)+\\cdots+2+1\\), which is the triangular sum.\nThen, we know number of iterations=\\(\\dfrac{n(n-1)}{2}\\).\nThis indicates that the runtime is \\(\\mathcal{O}(n^2)\\).\n\n\nAdditional properties of sorting algorithms:\n\nIn-place: a sorting algorithm is in-place if it does not require another array to execute the algorithm.\nStable: a sorting algorithm is stable if it preserves the relative order of equal keys in the array.\n\nSelection sort is in-place but not stable."
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#bubble-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#bubble-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Bubble Sort",
    "text": "Bubble Sort\n\nThe bubble sort algorithm will:\n\nCompare every pair of adjacent element\nExchange(=swap) them if they are out of order.\n\nExample:\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n9\n5\n4\n8\n1\nOrignal array\n\n\n\n\n2\n9\n5\n4\n8\n1\n2 &lt; 9 –&gt; OK, no swap\n\n\n2\n9\n5\n4\n8\n1\n9 &gt; 5 –&gt; swap\n\n\n2\n5\n9\n4\n8\n1\n9 &gt; 4 –&gt; swap\n\n\n2\n5\n4\n9\n8\n1\n9 &gt; 8 –&gt; swap\n\n\n2\n5\n4\n8\n9\n1\n9 &gt; 1 –&gt; swap\n\n\n2\n5\n4\n8\n1\n9\nFinish first iteration\n\n\n\n\nNote that after 1 iteration, the largest element is at the end of the array (the correct position). Therefore, if we repeat \\(n-1\\) times, the array will be sorted.\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void bubbleSort(T[] arr) {\n    int n = arr.length;\n\n    for (int i = 0; i &lt; n-1; i++) { // repeat n-1 times\n        // compare every adjacent pair of elements\n        for (int j = 0; j &lt; n-1-i; j++) {\n            if (arr[j].compareTo(arr[j+1]) &gt; 0) { // if out of order\n                exch(arr, j, j+1); // swap\n            }\n        }\n    }\n}\n\nRuntime analysis:\n\nThe loop structure of bubble sort can be simplified as\nfor (int i = 0; i &lt; n-1; i++) {\n    for (int j = 0; j &lt; n-1-i; j++) {\n        doPrimitive();\n    }\n}\n\n\n\ni=\n0\n1\n2\n…\nn-3\nn-2\n\n\n\n\nj=\n0\n0\n0\n…\n0\n0\n\n\nj=\n1\n1\n1\n…\n1\n\n\n\n…\n…\n…\n…\n\n\n\n\n\nj=\nn-4\nn-4\nn-4\n\n\n\n\n\nj=\nn-3\nn-3\n\n\n\n\n\n\nj=\nn-2\n\n\n\n\n\n\n\n\n\nSo, number of iterations is \\((n-1)+(n-2)+(n-3)+\\cdots+2+1\\), which is the triangular sum.\nThen, we know number of iterations=\\(\\dfrac{n(n-1)}{2}\\).\nThis indicates that the runtime is \\(\\mathcal{O}(n^2)\\).\n\n\nIn fact, we can improve the basic bubble sort algorithms.\nThe idea is that if we find that the array is already sorted, we can stop the algorithm.\n\nFacts:\n\nIn each iteration, the bubble sort algorithm will compare every pair of elements and swap only out-of-place pairs.\nWhen the array is sorted: an (entire) iteration in bubble sort will not perform any exchange operation.\n\nSo, we can add a variable to track the number of swaps in each iteration. If we find that the number of swaps is zero, we can stop the algorithm.\n\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void bubbleSort(T[] arr) {\n    int n = arr.length;\n    boolean swapped; \n\n    for (int i = 0; i &lt; n-1; i++) { // repeat n-1 times\n        swapped = false; // reset swapped to false\n        // compare every adjacent pair of elements\n        for (int j = 0; j &lt; n-1-i; j++) {\n            if (arr[j].compareTo(arr[j+1]) &gt; 0) { // out of order\n                exch(arr, j, j+1); // swap\n                swapped = true; // set swapped to true\n            }\n        }\n\n        if (swap == false) { // if no swap in this iteration\n            break; // stop the algorithm\n        }\n    }\n}\n\nThe bubble sort algorithm is an in-place and stable sorting algorithm."
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#insertion-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#insertion-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Insertion Sort",
    "text": "Insertion Sort\n\nThe insertion sort algorithm will:\n\nSelections the next unsorted element/key in the array\nInsert(=exchange) it towards the front into its correct position\n\nExample:\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n9\n5\n4\n8\n1\nOriginal array\n\n\n\n\n2\n9\n5\n4\n8\n1\n2 is in the correct position\n\n\n2\n9\n5\n4\n8\n1\n9 is in the correct position\n\n\n2\n9\n5\n4\n8\n1\n5 is not in the correct position, swap\n\n\n2\n5\n9\n4\n8\n1\n5 is not in the correct position, swap\n\n\n2\n4\n5\n9\n8\n1\n8 is not in the correct position, swap\n\n\n2\n4\n5\n8\n9\n1\n9 is not in the correct position, swap\n\n\n1\n2\n4\n5\n8\n9\nFinished!\n\n\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void insertionSort(T[] arr) {\n    int n = arr.length;\n\n    for (int i = 1; i &lt; n; i++) { // Repeat n-1 times\n        // Compare adjacent pairs starting at (i-1, i)\n        for (int j = i; j &lt; 0; j--) {\n            if (arr[j-1].compareTo(arr[j]) &gt; 0) { // out of order\n                exch(arr, j-1, j); // swap\n            } else {\n                break; // stop the inner loop\n            }\n        }\n    }\n}\n\nRuntime analysis:\n\nThe loop structure of the insertion sort algorithm can be simplified as:\nfor (int i = 1; i &lt; n; i++) {\n    for (int j = i; j &gt; 0; j--) {\n        doPrimitive();\n    }\n}\n\n\n\ni=\n1\n2\n3\n…\nn-2\nn-1\n\n\n\n\nj=\n1\n2\n3\n…\nn-2\nn-1\n\n\nj=\n\n1\n2\n…\nn-3\nn-2\n\n\n…\n…\n…\n…\n\n\n\n\n\nj=\n\n\n\n\n\n1\n\n\n\n\nSo, number of iterations is \\(1+2+3+\\cdots+(n-2)+(n-1)\\), which is the triangular sum.\nThen, we know number of iterations=\\(\\dfrac{n(n-1)}{2}\\).\nThis indicates that the runtime is \\(\\mathcal{O}(n^2)\\).\n\n\nThe selection sort algorithm is an in-place and stable sorting algorithm."
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#merge-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#merge-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Merge Sort",
    "text": "Merge Sort\n\nMerge Algorithm\n\nWe are given two sorted array portions that are adjacent to each other:\n\nInput:\nA[]:    ...... A[s] ... A[m-1] A[m] ... A[e-1] ...\n               &lt;-------------&gt; &lt;-------------&gt;\n                    sorted          sorted\n\nWe will design an efficient algorithm to merge the 2 sorted array portions. The result will then occupy the same portion in the array.\nParameters of the merge algorithm:\n\nThey merge algorithm has 3(index) parameters: s, m, and e.\ns: the starting index of the first sorted array portion.\nm: the ending index of the first sorted array portion.\ne: the ending index of the second sorted array portion.\n\nThe merge algorithm will:\n\nonly merge the array elements inside A[s] ... A[e-1]\nnot affect the array elements outside the range.\n\nVariables used in the merge algorithm:\n\nWe use 2 indices i and j to point to the current elements in each sorted array portion:\n\nThe element A[i] is always the smallest value in the left (sorted) portion.\nThe element A[j] is always the smallest value in the right (sorted) portion.\n\nWe also use a helper array variable H[] array to perform the merge operation.\n\nWe will repeatedly copy the smallest value from both arrays to H[].\nIf A[j] &lt; A[i], we will copy A[j] to H[] and increment j.\nIf A[i] &lt; A[j], we will copy A[i] to H[] and increment i.\nWhen i == m, we know the left portion is exhausted, so we can copy the remaining elements in the right portion to H[].\nWhen i == m and j == e, both portions are exhausted, and H[] now contains the merged result. We will then copy H[] back to A[].\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void merge(T[] A, int s, int m, int e, T[] H) {\n// The merge() method will be invoked repeatedly. \n// If we create a helper array inside merge(), we would repeatedly allocated and de-allocate memory.\n// That is inefficient.\n// So, we create a helper array outside merge() and pass it as a parameter.\nint i = s, j = m; // current elements in left and right portions\nint k = 0; // current element in helper array\n\nwhile (i &lt; m || j &lt; e) { // loop as long as there are unprocessed items\n    if (i &lt; m && j &lt; e) {\n        // Case 1: both portions have unprocessed elements\n        if (A[i].compareTo(A[j]) &lt; 0) {\n            H[k++] = A[i++];\n        } else {\n            H[k++] = A[j++];\n        }\n    } else if (i == m) {\n        // Case 2: the left portion is exhausted\n        H[k++] == A[j++];\n    } else if (j == e) {\n        // Case e: the right portion is exhausted\n        H[k++] = A[i++];\n    }\n}\n\n// Copy H[] back to A[]\nfor (i = s, k = 0; i &lt; e; i++, k++) {\n    A[i] = H[k];\n}\n}\n\nRun time analysis:\n\nWe can simplify the while-loop into:\nwhile (i &lt; m || j &lt; e) {\n    doPrimitive();\n    // Then do either: \n    i++; // --&gt; i = s; i &lt; m; i++ = m-s times\n    // Or do: \n    j++; // --&gt; j = m; j &lt; e; j++ = e-m times\n}\n// Copy\nfor (int i = s, k = 0; i &lt; e; i++, k++) {\n    // i = s; i &lt; e; i++ = e-s times\n    doPrimitive();\n}\n\nThe while loop will be executed \\((m-s)+(e-m) = e-m=n\\) times.\nThe for loop will be executed \\(e-s=n\\) times.\nIn total, we have \\(2n\\) primitive operations.\nThe running time of the merge() algorithm is \\(2n\\), which is \\(\\mathcal{O}(n)\\).\n\n\n\n\n\nMerge Sort Algorithm\n\nThe Merge sort algorithm will:\n\nSplit the array a[] into 2 halves:\n\nan array left[] containing a[0] ... a[n/2]\nan array right[] containing a[n/2+1] ... a[n-1]\n\nSort both halves of the arrays (by repeating the above step)\nMerge the sorted arrays into the final sorted array\n\nThe recursive structure (illustration using selectinoSort):\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a, int s, int e, T[] H) {\n    if (e-s &lt;= 1) { // A[s]..A[e] has 0 or 1 elements\n        return; // nothing to sort\n    }\n    int m = (s+e)/2; // m is the middle index\n\n    /*\n     * Sort the left portion A[s]..A[m-1]\n     * Sort the right portion A[m]..A[e-1]\n     * Merge the sorted portions\n     */\n    selectionSort(A, s, m);\n    selectionSort(A, m, e);\n\n    // Merge both sorted arrays\n    merge(A, s, m, e, H);\n}\n\nNow, the real merge sort algorithm is simply to replace selectionSort() with mergeSort().\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] a, int s, int e, T[] H) {\n    if (e-s &lt;= 1) { // A[s]..A[e] has 0 or 1 elements\n        return; // nothing to sort\n    }\n    int m = (s+e)/2; // m is the middle index\n\n    /*\n     * Sort the left portion A[s]..A[m-1]\n     * Sort the right portion A[m]..A[e-1]\n     * Merge the sorted portions\n     */\n    mergeSort(A, s, m, H);\n    mergeSort(A, m, e, H);\n\n    // Merge both sorted arrays\n    merge(A, s, m, e, H);\n}\n\nThe merge sort algorithm is not an in-place sorting algorithm, but it is a stable sorting algorithm.\nRuntime analysis:\n\nIf we want to sort \\(n\\) elements, we can rewrite the algorithm into\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] a, int n, T[] H) {\n    if (n &lt;= 1) {\n        return;\n    }\n    mergeSort(a, n/2, H); // running time = T(n/2)\n    mergeSort(a, n/2, H); // running time = T(n/2)\n    // Final merge\n    merge(a, 0, n/2, n, H); // running time = 2n\n}\n\nSo, \\(T(n)=0\\) for \\(n\\leq 1\\) and \\(T(n)=2T\\left(\\dfrac{n}{2}\\right)+2n\\) for \\(n\\geq2\\).\nNow, let’s solving the following relationship: \\[\n\\begin{aligned}\nT(1)&=0\\\\\nT(n) &= 2T\\left(\\dfrac{n}{2}\\right)+2n \\\\\n&= 2\\left[2T\\left(\\dfrac{n}{4}\\right)+2\\left(\\dfrac{n}{2}\\right)\\right]+2n \\\\\n&=2^2T\\left(\\dfrac{n}{2^2}\\right)+2(2n) \\\\\n&=2^2\\left[2T\\left(\\dfrac{n}{2^3}\\right)+2\\left(\\dfrac{n}{2^2}\\right)\\right]+2(2n) \\\\\n&=2^3T\\left(\\dfrac{n}{2^3}\\right)+3(2n) \\\\\n&\\vdots \\\\\n&=2^kT\\left(\\dfrac{n}{2^k}\\right)+k(2n) \\\\\n\\text{Set }\\dfrac{n}{2^k}=1&\\implies 2^k=n\\implies k=\\log(n)\\\\\nT(n)&=2^kT\\left(\\dfrac{n}{2^k}\\right)+k(2n) \\\\\n&=2^kT(1)+2kn \\\\\n&=0+2kn=2n\\log(n) \\\\\n\\end{aligned}\n\\]\nSo, the running time is \\(T(n)=2n\\log(n)\\), which is \\(\\mathcal{O}(n\\log(n))\\).\n\n\nMerge sort is one of few algorithms that has a runtime of \\(\\mathcal{O}(n\\log(n))\\).\n\n\\(\\mathcal{O}(n\\log(n))\\) is the theoretical lower bound on running time of sorting algorithms.\n\nSome problems with pure merge sort algorithm:\n\nThere is a very high overhead to executive a recursive algorithm for tiny sublists.\nMerge sort will merge even when the 2 halves are sorted.\nMerge sort is not an in-place algorithm.\n\nMerge sort requires an additional array to perform the merge operation.\n\n\nTo solve the first problem, we can have a cutoff value for the size of the sublist. If the size of the sublist is smaller than the cutoff value, we will use selection sort instead of merge sort. This hybrid algorithm is called Tim Sort.\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] A, int s, int e, T[] H) {\n    if (e - s &lt;= CUTOFF) {\n        selectionSort(A, s, e);\n        return;\n    }\n    int m = (s + e) / 2;\n    mergeSort(A, s, m, H);\n    mergeSort(A, m, e, H);\n    // Merge both sorted arrays\n    merge(A, s, m, e, H);\n}\n\nTo solve the second problem, we can simply add a comparison of the last element in the left portion and the first element in the right portion. If the last element in the left portion is smaller than the first element in the right portion, we can skip the merge operation.\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] A, int s, int e, T[] H) {\n    if (e - s &lt;= CUTOFF) {\n        selectionSort(A, s, e);\n        return;\n    }\n    int m = (s + e) / 2;\n    mergeSort(A, s, m, H);\n    mergeSort(A, m, e, H);\n    // Merge both sorted arrays only when values over lap\n    if (A[m-1].compareTo(A[m]) &lt; 0) {\n        return;\n    }\n    merge(A, s, m, e, H);\n}\n\n\nNon-recursive Merge Sort\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] A, T[] H) {\n    int mergeSize = 1;\n\n    while (mergeSize &lt; A.length) {\n        int s, m, e;\n        for (s = 0; s &lt; A.length; s += 2*mergeSize) {\n            m = s + mergeSize;\n            e = Math.min(s + 2*mergeSize, A.length);\n            merge(A, s, m, e, H);\n        }\n        mergeSize *= 2;\n    }\n}\nA[]: | mergeSize | mergeSize | mergeSize | mergeSize | ...\n     s           m          e/s          m           e"
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#quick-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#quick-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Quick Sort",
    "text": "Quick Sort\n\nIntroduction to Quick Sort\n\nQuick sort is the most commonly used sorting algorithm.\nQuick sort was invented by Antony Hoare in 1959 and was honored as one of the top 10 algorithms in the 20th centry.\nSome facts on quick sort:\n\nIt is a divide-and-conquer algorithm. (just like merge sort)\n\nUnlike merge sort, quick sort is an in-place algorithm. So it does not require an extra array.\n\nBig idea of quick sort:\n\nWe select a pivot element in the array.\nWe partition the array into 2 portions:\n\nThe left portion contains elements that are smaller than the pivot.\nThe right portion contains elements that are larger than the pivot.\n\nInsert the pivot to the correct position.\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void quickSort(T[] A, int s, int e) {\n  if (e - s &lt;= 1) { // Base case\n      return;\n  }\n  // partition sub array A[s]..A[e-1] using A[s] as pivot\n  int pivotLoc = partition(A, s, e);\n  // partiion(A, s, e) returns the index (=location) of the pivot element. \n  // it is the border of the 2 sub array/groups\n  quickSort(A, s, pivotLoc); // sort left portion\n  quickSort(A, pivotLoc+1, e); // sort right portion\n}\n\n\nThe Partition Algorithm for Quick Sort\n\nA simplified partition algorithm:\n\nA partitioning algorithm maintains 2 half arrays: a low half and a high half.\nThe simplified partitioning algorithm only compares the pivot against A[high].\n           low half                   high half\nA[] = [P L L L L L L ? ? ? ? ? ? ? X H H H H H H]\n       ^ &lt;---------&gt; ^             ^ &lt;---------&gt;\n       |     &lt;P      |             |     &gt;= P   \n     pivot          low           high\n       |                           |\n       +---------------------------+\n        compares: pivot &lt;==&gt; A[high]\n\nIf A[high] (X) &gt;= pivot, then A[high] belongs to the high partition, and we decrement high\n\n           low half                   high half\nA[] = [P L L L L L L ? ? ? ? ? ? ? X H H H H H H]\n       ^ &lt;---------&gt; ^           ^ &lt;-----------&gt;\n       |     &lt;P      |           |     &gt;= P   \n     pivot          low         high\n       |                         |\n       +-------------------------+\n        compares: pivot &lt;==&gt; A[high]\n\nIf A[high] (X) &lt; pivot, then A[high] belongs to the low partition: we exchange X and Y and then increment low.\n\n           low half                   high half\nA[] = [P L L L L L L Y ? ? ? ? ? ? X H H H H H H]\n       ^ &lt;---------&gt; ^             ^ &lt;---------&gt;\n       |     &lt;P      |             |     &gt;= P   \n     pivot          low           high\n\n           low half                   high half\nA[] = [P L L L L L L X ? ? ? ? ? ? Y H H H H H H]\n       ^ &lt;-----------&gt; ^           ^ &lt;---------&gt;\n       |     &lt;P        |           |     &gt;= P   \n     pivot            low         high\n\nWe repeat the steps until we get low &gt; high. Then, we will put the pivot in its correct location by exchanging pivot and A[high].\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; int partition(T[] A, int s, int e) {\nT pivot = A[s];\nint low = s, high = e - 1;\n\nwhile (low &lt;= hight) {\n    if (A[high].compareTo(pivot) &gt;= 0) {\n        high--;\n    } else {\n        exch(A, low, high);\n        low++;\n    }\n}\nexch(A, s, high); // A[s] = pivot\nreturn high;\n}\n\nA rather complicated partitioning algorithm:\n\npublic static int partition(int[] list, int first, int last) {\n    int pivot = list[first]; // choose the first element as the pivot\n    int low = first + 1; // index for forward search\n    int high = last - 1; // index for backward search\n\n    while (low &lt; high) {\n        // Search forward from left\n        while (low &lt;= high && list[low] &lt;= pivot) {\n            low++;\n        }\n        // Search backward from right\n        while (low &lt;= high && list[high] &gt; pivot) {\n            high--;\n        }\n        // Swap two elements in the list\n        if (low &lt; high) {\n            int temp = list[high];\n            list[high] = list[low];\n            list[low] = temp;\n        }\n    }\n    // Adjust high to find the border\n    while (high &gt; first && list[high] &gt;= pivot) {\n        high--;\n    }\n    // Swap pivot with list[high]\n    if (pivot &gt; list[high]) {\n        list[first] = list[high];\n        list[high] = pivot;\n        return high;\n    } else {\n        return first; // pivot was the smallest element\n    }\n}\n\nThe quick sort algorithm is an in-place algorithm, but it is not stable.\n\n\n\nRuntime Analysis\n\nSynopsis of the partition() algorithm java     public statbic &lt;T extends Comparable&lt;T&gt;&gt; int partition(T[] A, int s, int e) {         T pivot = A[s];         int low = s+1; high = e-1;         while (low &lt;= high) {             doPrimitive(); // either high--; or low++             // --&gt; loop will run (e-1) - (s+1) times = e-1-s-1=e-s-2 times         }         doPrimitive(); // exchange pivot and A[high]         return hight;     }\n\nIn this case, the running time will be \\(n-1\\approx n\\). Or, \\(\\mathcal{O}(n)\\).\n\nThe running time of the quick sort algorithm depends on how partition() splits the input array.\n\nIMPORTANT: the running time of quick sort depends on how large the 2 array halves are.\nSuppose the partition(A, s, e) algorithm partitions the input as follows:\n         &lt;-------------- n ---------------&gt;\nINPUT:  [P .. .. .. .. .. .. .. .. .. .. ..]\nRESULT: [.. .. .. .. .. .. P .. .. .. .. ..]\n         &lt;------ k ------&gt;   &lt;--- n-k-1 --&gt;\n\nThe running time \\(T(n)\\) for input size \\(n\\) will have the following recurrence relationship: \\(T(n)=T(k)+T(n-k-1)+n\\).\n\n\nThe best case running time of quick sort.\n\nThe best case running time of the quick sort algorithm happens when: the partition() algorithm always divides the input array into 2 equal halves.\nIn this case, we have \\[\n\\begin{aligned}\nT(n)&=T(k)+T(n-k-1)+n\\\\\n&=T(n/2) + T(n/2-1) + n\\\\\n&\\approx 2T(n/2) + n,\n\\end{aligned}\n\\] which is similar recurrence relation as the one in merge sort.\n\nSo, we can solve it with telescoping and the result is \\(T(n)=n\\log(n)\\).\n\n\nThe worst case running time of quick sort:\n\nThe worst case running time of the quick sort algorithm happens when the partition() always divides the input array into (1) array containing the pivot and (2) an array with \\(n-1\\) elements.\nIn this case, we have \\[\n\\begin{aligned}\nT(n)&=T(0)+T(n-1)+n\\\\\n&=0+T(n-1)+n\\\\\n&=T(n-1)+n\\\\\n&=T(n-2)+(n-1)+n\\\\\n&=T(n-3)+(n-2)+(n-1)+n\\\\\n&\\vdots\\\\\n&=T(0)+1+2+\\cdots+(n-2)+(n-1)+n\\\\\n&=1+2+\\cdots+(n-2)+(n-1)+n&\\text{triangular sum}\\\\\n&=\\dfrac{n(n+1)}{2}-1\\\\\n&=\\mathcal{O}(n^2)\n\\end{aligned}\n\\]\nSo, the worse case running time is \\(\\mathcal{O}(n^2)\\).\nAn example that makes quick sort achieve the worse case running time: a sorted array.\n\nBecause the pivot is always the smallest value, partition() will always produce:\n\nAn array containing the pivot, and\nAn array containing the other \\(n-1\\) elements.\n\n\nTo prevent the worse case, a commonly used practice when using quick sort is to:\n\nShuffle the input array randomly (To ensure partition() will not always find the pivot as the first element)\nUse quick sort of the shuffled input array.\nThen, the quick sort will achieve the average running time performance with a randomized input array.\n\n\nThe average running time of quick sort:\n\nRecall the recurrence relation for the running time of quick sort is \\(T(n)=T(k)+T(n-k-1)+n\\), where \\(k\\) is the final position of the pivot.\nDepending on the value of \\(k\\), the recurrence relation for \\(T(n)\\) are different: \\[\nT(n)=T(0)+T(n-1)+n\\quad\\text{ if }k=0\\\\\nT(n)=T(1)+T(n-2)+n\\quad\\text{ if }k=1\\\\\n\\cdots\\\\\nT(n)=T(n-1)+T(0)+n\\quad\\text{ if }k=n-1\n\\]\nSince each value of \\(k\\) is equally likely to occur, we can take the average by summing them and dividing the sum by \\(n\\). \\[\nnT(n)=(T(0)+\\cdots+T(n-1))+(T(n-1)+\\cdots+T(0))+n^2\\\\\nnT(n)=2T(0)+2T(1)+\\cdots+2T(n-1)+n^2\\\\\nT(n)=\\dfrac{2}{n}T(0)+\\dfrac{2}{n}T(1)+\\cdots+\\dfrac{2}{n}T(n-1)+n\n\\]\nNow, we want to solve the following recurrence relation: \\[\n\\begin{aligned}\nT(1)&=1\\\\\nT(n)&=\\dfrac{2}{n}T(0)+\\dfrac{2}{n}T(1)+\\cdots+\\dfrac{2}{n}T(n-1)+n\\\\\nnT(n)&=2T(0)+2T(1)+\\cdots+2T(n-1)+n^2\\\\\n(n-1)T(n-1)&=2T(0)+2T(1)+\\cdots+2T(n-2)+(n-1)^2\\\\\nnT(n)-(n-1)T(n-1)&=2T(n-1)+n^2-(n-1)^2\\\\\n&=2T(n-1)+2n-1\\\\\nnT(n)&=(n+1)T(n-1)+2n-1\\\\\nT(n)&=\\dfrac{n+1}{n}T(n-1)+2-\\dfrac{1}{n}\\\\\n\\dfrac{T(n)}{(n+1)}&=\\dfrac{T(n-1)}{n}+\\dfrac{2}{(n+1)}-\\dfrac{1}{n(n+1)}\\\\\n\\dfrac{T(n-1)}{n}&=\\dfrac{T(n-2)}{(n-1)}+\\dfrac{2}{n}-\\dfrac{1}{(n-1)n}\\\\\n\\dfrac{T(n-2)}{(n-1)}&=\\dfrac{T(n-3)}{(n-2)}+\\dfrac{2}{(n-1)}-\\dfrac{1}{(n-2)(n-1)}\\\\\n&\\vdots\\\\\n\\dfrac{T(2)}{3}&=\\dfrac{T(1)}{2}+\\dfrac{2}{3}-\\dfrac{1}{2\\cdot3}\\\\\n\\dfrac{T(n)}{(n+1)}&+\\dfrac{T(n-1)}{n}+\\dfrac{T(n-2)}{(n-1)}+\\cdots+\\dfrac{T(2)}{3}\\\\\n&=\\dfrac{T(n-1)}{n}+\\dfrac{T(n-2)}{(n-1)}+\\cdots+\\dfrac{T(2)}{3}+\\dfrac{T(1)}{2}\\\\\n&\\quad+\\dfrac{2}{(n+1)}+\\dfrac{2}{n}+\\dfrac{2}{(n-1)}+\\cdots+\\dfrac{2}{3}\\\\\n&\\quad-\\dfrac{1}{n(n+1)}-\\dfrac{1}{(n-1)n}-\\cdots-\\dfrac{1}{3\\cdot2}\\\\\n\\dfrac{T(n)}{(n+1)}&\\approx2\\left(\\dfrac{1}{(n+1)}+\\dfrac{1}{n}+\\dfrac{1}{(n-1)}+\\cdots+\\dfrac{1}{3}+\\dfrac{1}{2}+1\\right)\\\\\n&=2\\log(n+1)\n\\end{aligned}\n\\]\n\nTherefore, \\(T(n)=2(n+1)\\log(n+1)\\), or \\(\\mathcal{O}(n\\log(n))\\).\n\n\n\n\n\nImprovements to Quick Sort\n\nAs mentioned above, one way to improve the quick sort algorithm is to shuffle the input array randomly. ```java public static void main(String[] args) { Integer[] A = …; // Array to be sorted with quick sort\n  // shuffle array A\n  for (int k = 0; k &lt; N; k++) {\n      int i = Math.random() * A.length;\n      int j = Math.random() * A.length;\n      exch(A, i, j);\n  }\n  quickSort(A, 0, A.length);\n} ```\n\nWhy shuffle?\n\nMake quick sort avoid picking the smallest pivot all the time.\nHelp quick sort achieve the average running time performance with a randomized array.\n\n\nAnother way to improve the quick sort algorithm is the increase the likelihood to partition the array into 2 equal halves.\n\nThe best pivot value is the median of the input array.\nWe can improve the likelihood of picking the median by considering 3 (random value) selected from the input array. (Instead of always using the first element as pivot).\nThe median of 3 partition method:\nA[] = [X .. .. .. .. .. Y .. .. .. .. .. Z]\nLet M = median(X, Y, Z)\n    (1) swap M and X\n    (2) partition(A, s, e)\nAlgorithm to find the median of 3 values:\npublic static int medianOf3(int a, int b, int c) {\n    if ((b &lt;= a && a &lt;= c) || (c &lt;= a && a&lt;= b)) {\n        return a;\n    }\n    if ((a&lt;= b && b &lt;= c) || (c &lt;= b && b &lt;= a)) {\n        return b;\n    }\n    return c;\n}\n\nAn improved (faster) algorithm: using the exclusive OR (^) operator.\n\npublic static int medianOf3(int a, int b, int c) {\n    if ((a &gt; b) ^ (a &gt; c)) { // either a &gt; b or a &gt; c\n        return a;\n    }\n    if ((b &gt; a) ^ (b &gt; c)) { // either b &gt; a or b &gt; c\n        return b;\n    }\n    return c;\n}"
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#faster-computer-vs-better-algorithm.",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#faster-computer-vs-better-algorithm.",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Faster Computer VS Better algorithm.",
    "text": "Faster Computer VS Better algorithm.\n\nConsider:\n\nA sorting algorithm (e.g. merge sort) with \\(\\mathcal{O}(n\\log(n))\\) running time.\nA sorting algorithm (e.g. insertion sort) with \\(\\mathcal{O}(n^2)\\) running time running on a faster computer (e.g. 1,000,000 times faster).\n\nWhich one is better?\n\nThe answer is: it depends.\nIf the input size is small, the faster computer will be better.\nIf the input size is large, the better algorithm will be better.\nA better algorithm will always beat an average algorithm when the input size is sufficiently large."
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#sorting-algorithms-in-javas-library",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#sorting-algorithms-in-javas-library",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Sorting Algorithms in Java’s Library",
    "text": "Sorting Algorithms in Java’s Library\n\nThe sort() method (an overloaded method) can be found in:\n\njava.util.Arrays to sort arrays:\n\nsort(int[] a): the sorting algorithm is a Dual-Pivot Quick Sort.\nsort(Object[] a): This implementation is a stable, adaptive, iterative Merge Sort.\n\njava.util.Collections to sort collections (e.g. ArrayList):\n\nAccording to information on the Internet, they used Merge Sort in Collections.\n\n\nRequirement to use sort() methods in Java’s library:\n\nThe objects that are sorted must implement the Comparable&lt;T&gt; interface."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "",
    "text": "Problem: we need to write a program (software) to solve a new problem (How to re-sue existing software to build more complex software prior to ~1995, invention of OOP)\n\nWe want to write a NewClass class to solve the problem\nWe find a program (SomeClass) that can be used as the starting point to build our more complex software.\nWe make a copy of the program.\nThen, we make changes to the copy of software, so the new software does what we want.\nHowever, we have the problem of:\n\nRedundancy: we can have multiple copies of the same method\nHard to maintain programs: when we update the original software (from which we made the new software), we may need to update our programs that are based on the existing software\n\n\nAfter the invention of OOP, we define (not copying!) the new class to inherit from the original class.\n\nThe new class will inherit(=receive) all the variables and (normal) methods from an existing class\n\n\n\n\n\n\n\n\nTip 1: Example of Inheritance\n\n\n\n\n\npublic class SomeClass{\n  public int x;\n  public SomeClass{ \n      x = 99;\n  }\n  public void method1() {\n      System.out.println(\"I am SomeClass.method1(). x = \" + x);\n  }\n  public void method2 () {\n      System.out.println(\"I am Someclass.method2(). x = \" + x);\n  }\n}\npublic class NewClass extends SomeClass{ \n  NewClass() { }\n  // No other methods defined\n}\npublic static void main(String[] args) {\n  NewClass b = new NewClass();\n  b.method1(); // Invokes SomeClass.method1()\n  b.method2(); // Invokes SomeClass.method2()\n}\n\n\n\n\nIf An inherited method is not appropriate (does not do what we want), we replace (override) that method with a new method with the same signature.\n\nMethods defined inside the NewClass will take priority over an inherited method with the same method signature (this mechanism is called overriding).\n\nIf original class does not have a suitable method for some task in the new class, we can add new methods to our NewClass to perform that task.\n\nThese new methods will only be defined in the NewClass (and will not be defined or inherit in the original class).\nSee Demo02.java and NewClass02.java\n\nAccessing an overridden method and an overriding method:\n\nNotice there are two different methods named method1() with the same signature if we override the method.\n\nThe original method1() is in SomeClasses (the overridden method)\nThe new method1() is in NewClass (the overriding method)\nWhen writing methods in NewClass, both methods are available for use (=accessible).\n\nTo access the overridden method, we use the super keyword, which always refers to the members in the super class.\n\nFor example, super.method1() refers to the method1() defined in SomeClass\n\n\nImportant note: Accessibility modifiers are enforced on inherited members.\n\nNote: the subclass and its superclass are separate class.\nTherefore, methods defined (written) inside a subclass cannot access private members in the super class.\nOnly the unmodified inherited methods in the subclass can access the inherited private members."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-inheritance",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-inheritance",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "",
    "text": "Problem: we need to write a program (software) to solve a new problem (How to re-sue existing software to build more complex software prior to ~1995, invention of OOP)\n\nWe want to write a NewClass class to solve the problem\nWe find a program (SomeClass) that can be used as the starting point to build our more complex software.\nWe make a copy of the program.\nThen, we make changes to the copy of software, so the new software does what we want.\nHowever, we have the problem of:\n\nRedundancy: we can have multiple copies of the same method\nHard to maintain programs: when we update the original software (from which we made the new software), we may need to update our programs that are based on the existing software\n\n\nAfter the invention of OOP, we define (not copying!) the new class to inherit from the original class.\n\nThe new class will inherit(=receive) all the variables and (normal) methods from an existing class\n\n\n\n\n\n\n\n\nTip 1: Example of Inheritance\n\n\n\n\n\npublic class SomeClass{\n  public int x;\n  public SomeClass{ \n      x = 99;\n  }\n  public void method1() {\n      System.out.println(\"I am SomeClass.method1(). x = \" + x);\n  }\n  public void method2 () {\n      System.out.println(\"I am Someclass.method2(). x = \" + x);\n  }\n}\npublic class NewClass extends SomeClass{ \n  NewClass() { }\n  // No other methods defined\n}\npublic static void main(String[] args) {\n  NewClass b = new NewClass();\n  b.method1(); // Invokes SomeClass.method1()\n  b.method2(); // Invokes SomeClass.method2()\n}\n\n\n\n\nIf An inherited method is not appropriate (does not do what we want), we replace (override) that method with a new method with the same signature.\n\nMethods defined inside the NewClass will take priority over an inherited method with the same method signature (this mechanism is called overriding).\n\nIf original class does not have a suitable method for some task in the new class, we can add new methods to our NewClass to perform that task.\n\nThese new methods will only be defined in the NewClass (and will not be defined or inherit in the original class).\nSee Demo02.java and NewClass02.java\n\nAccessing an overridden method and an overriding method:\n\nNotice there are two different methods named method1() with the same signature if we override the method.\n\nThe original method1() is in SomeClasses (the overridden method)\nThe new method1() is in NewClass (the overriding method)\nWhen writing methods in NewClass, both methods are available for use (=accessible).\n\nTo access the overridden method, we use the super keyword, which always refers to the members in the super class.\n\nFor example, super.method1() refers to the method1() defined in SomeClass\n\n\nImportant note: Accessibility modifiers are enforced on inherited members.\n\nNote: the subclass and its superclass are separate class.\nTherefore, methods defined (written) inside a subclass cannot access private members in the super class.\nOnly the unmodified inherited methods in the subclass can access the inherited private members."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriented-thinking",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriented-thinking",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Object-Oriented Thinking",
    "text": "Object-Oriented Thinking\n\nObject-Oriented Thinking\n\nIn order to maximize the inheritance mechanism to re-use existing software, we need to adopt the Object-Oriented Design methodology when developing the classes.\nThe Object-Oriented Design methodology organizes object class in a hierarchy according to common properties and actions\nThe Object-Oriented methodology can minimize the re-use of variables and methods.\n\nHow to maximize the sharing of properties and/or actions among classes\n\nWe use a class to model objects of the same type\nDifferent classes can have common properties and/or behaviors\nTo maximize sharing of common properties/behaviors, we generalize different classes into a large (super) class.\n\nThe is-a generalization method will give us the maximum sharing of properties and actions\n\n\nThe Object-Oriented Design methodology uses the is-a generalization technique to achieve maximal sharing of properties and actions between classes.\nHow to design the class hierarchy using the is-a generalization technique\n\nFirst, determine all the program classes that we will need to solve the problem. Determine the properties and actions that are needed in each class.\nThen, generalize similar program classes using the is-a generalization. Use the properties and actions in each class to find the more general classes.\nIf possible, generalize further. Use the final hierarchy to determine the properties and actions of each class. &gt; Superclass: the more general class in the is-a relationship (aka, parent class)\nA super class has a number of properties and actions. &gt; Subclass: the more specific class in the is-a relationship (aka, child class)\nEvery object of the subclass will have all the properties and actions in the superclass.\nIn addition, the subclass object can have other properties and actions not found in the superclass.\n\nSee TestGeometricObject.java\n\n\nThe OOP design allows us to avoid duplications of codes when solving a problem. - See TestOldWay.java\n\nWe define a superclass that contains the common (shared) properties and actions in all classes\n\nSome methods in the superclass may not have a useful method body - it’s OK. This is very useful for the polymorphism mechanism.\n\nWe create subclasses that extend the superclass.\n\nFor private instance variables, we must use its accessor/mutator methods to use the variables.\nFor public instance variables, we can access them directly.\n\nWe can override some methods in the subclass.\n\nRelationship between a subclass and its superclass\n\nA subclass inherits all variables and (normal) methods from its superclass.\nA subclass do not inherit any constructor method from its superclass.\n\nA constructor in the subclass must invoke a constructor in the superclass\nA subclass object always contains a superclass object.\nObjects are initialized using its constructor\n\nRule: a constructor in the subclass must invoke some constructor in its superclass as its first statement.\n\nThe keyword super(...) is used to invoke a constructor in its superclass.\n\nRule: if a constructor in the subclass does not invoke any constructor in its superclass, then, the Java compiler will automatically insert the call super() as the first statement. That is, when the first statement in a constructor is not super(...), the Java compiler will call the default constructor.\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    // Compile error -- why?\n  }\n}\n\npublic class SomeClass {\n  public int x;\n  public SomeClass(int a) {\n    x = a;\n  }\n}\n\nThe compile error is because the constructor NewClass() does not contain any super(...) calls, so Java compile will insert super(...):\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    super();\n  }\n}\n\nHowever, there is not matching constructor (SomeClass()) defined in the supercalss, which causes the error.\n\nConsequences of the constructor invocation rule in Java:\n\nConstructor invocation rule in Java:\n\nIf a class B inherits from class A, then every constructor in class B must invoke some constructor in class A.\n\nConsequence:\n\nIf another class C inherits from the class B, then every constructor in class C must invoke some constructor in class B and in class A.\nThis phenomenon is called constructor chaining.\n\n\nSummary:\n\nA subclass inherits all normal members (including private members) from its superclass\nMethods in the subclass cannot access the private inherited members directly.\nA subclass object contains (all members in) a supercalss object.\nA subclass do not inherit any constructors from its superclass.\nBecause a subclass object contains (All members in) a superclass object, every constructor in the subclass must invoke a constructor in the superclass.\n\nSometimes, we must use the overridden method inside the super class (i.e., use super.methodName())\nSee 05-bank-account:\n\nBankAccount.java\nSavingAccount.java\nTestSavingAccount.java"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#overloading-vs.-overriding",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#overloading-vs.-overriding",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Overloading vs. Overriding",
    "text": "Overloading vs. Overriding\n\n\n\n\n\n\nNote 1: Overloading\n\n\n\nDefining different methods with the same (method) name but with different (method) signatures\n\n\n\n\n\n\n\n\nTip 2: Example of Overloading\n\n\n\n\n\npublic class SomeClass {\n  public int x;\n  public SomeClass (int a) {\n    x = a;\n  }\n  public void method1() {\n    System.out.println(\"SomeClass.method1()\");\n  }\n  public void method2() {\n    System.out.println(\"SomeClass.method2()\");\n  }\n}\npublic class NewClass extends SomeClass {\n  NewClass (int a) {\n    super(a);\n  }\n  // Inherits: method1() and method2()\n  public void method1(int a) { // Overloads method1()\n    System.out.println(\"NewClass.m1(int)\");\n  }\n  public void method3() {\n    method1(); // Invokes SomeClass method1\n    method1(22); // Invokes NewClass method1(int)\n  }\n}\n\n\n\n\n\n\n\n\n\nNote 2: Overriding\n\n\n\nReplacing an inherited method by defining a method with the same (method) signature\n\n\n\n\n\n\n\n\nTip 3: Example of Overriding\n\n\n\n\n\npublic class NewClass extends SomeClass {\n  NewClass(int a) {\n    super(a);\n  }\n  // Inherites: method1() and method2()\n  public void method1() { // overrides method1()\n    System.out.println(\"NewClass.m1()\");\n  }\n  public void method3() {\n    method1(); // Invokes NewClass method1\n    super.method1(); // Invokes SomeClass method1\n  }\n}\n\n\n\n\nIn Java, we can add the special override annotation @Override before an overriding method for clarity: java     public class NewClass extends SomeClass {       // Inherits: method1(double)       @Override       public void method1(double x) {         System.out.println(\"x = \" + x);       }     }\n\nJava compiler will report an error if the defined method does not override any inherited methods.\n\nAdditional conditions on overriding methods\n\nThe overriding method must have the same return type as the overridden method. We will get a type incompatible error when we use different return types.\nThe overriding method should have the same accessibility modifier as the overridden method. Complicated errors can result when you do not use the same accessibility."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#things-that-the-java-compiler-does-automatically",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#things-that-the-java-compiler-does-automatically",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Things that the Java Compiler does automatically",
    "text": "Things that the Java Compiler does automatically\n\nEvery object must be initialized; therefore\n\nEvery class must have a constructor method\nif a class does not have one, the Java compiler will insert the default constructor\n\nEvery subclass object contains a superclass object (that must be initialized); therefore\n\nA subclass constructor must invoke super() as its first statement.\nIf not so, the Java compiler will insert super(); at the beginning.\n\nEvery class in Java is descended from one special class called the Object class. i.e., the Object class is the parent class of every class in any Java program\n\nIf no inheritance is specified when a class is defined, the Java compiler will automatically insert extends Object in the class definition.\nEvery class in Java inherits from the Object class.\nEvery object in Java will have all the methods defined in the Object class.\n\nOne important method in the Object class is toString()\n\ntoString() returns a string representation of this object.\nFurthermore, the System.out.println() method invokes the toString() method so it can print out any object.\nTherefore, we can control the print out of an object by overriding the toString() in a class."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-polymorphism",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-polymorphism",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Introduction to Polymorphism",
    "text": "Introduction to Polymorphism\n\nSo far, we have always used a reference variable to point to an object of the same class. Now, we will use a reference variable to point to an object of a different class.\n\n\n\n\n\n\n\nTip 4: Example of Polymorphism\n\n\n\n\n\npublic class SomeClass {\n  public int x = 44;\n  public void method1() {\n    System.out.println(\"SomeClass.m1()\");\n  }\n  public void method2() {\n    System.out.println(\"SomeClass.m2()\");\n  }\n}\n\nThen, the following are legal\n\nDefine a reference variable: SomeClass a;\nCreate a SomeClass object: a = new SomeClass();\na.x\na.method1()\na.method2()\n\n\n\n\n\n\nThe Correctness of Program Execution (Suppose a SomeClass variable a is referencing to some arbitrary object with a.x, a.method1(), and a.method2() defined)\n\nRule: a reference variable must refer to an object that contains all members in a legal request\n\nReason: the referred object must perform all acrtions in the class or else we can have a request error.\nThe simplest way to satisfy this rule is to refer to an object of the same class.\nHowever, there is another safe (=correct) way due to the inheritance relationship.\n\nA subclass object can perform all actions that a superclass object performs.\n\nTherefore, it is safe to use a superclass reference variable to request members in a subclass object.\nJava allows we to access members in a subclass object using a superclass reference variable.\n\n\nDynamic Dispatch (aka: late binding)\n\nThe request a.method() will execute the method in the object that a is currently pointing to.\nThis feature is called dynamic dispatch or late binding, which means decision on which method to run is at the last moment.\n\n\n\n\n\n\n\n\nTip 5\n\n\n\n\n\npublic class SomeClass {\n    public int x = 44;\n    public void method1() {\n      System.out.println(\"SomeClass.m1()\");\n    }\n    public void method2() {\n      System.out.println(\"SomeClass.m2()\");\n    }\n}\npublic class NewClass extends SomeClass {\n    @Override\n    public void method1() {\n      System.out.println(\"NewClass.m1()\");\n    }\n    public void method3() {\n      System.out.println(\"newClass.m3()\");\n    }\n}\npublic class myProg {\n    public class void main(String[] args) {\n      SomeClass a = new NewClass(); // allowed!\n      System.out.println(a.x);\n      a.method1(); // Invokes method1() in NewClass\n      a.method2();\n      a.method3(); // illegal\n    }\n  }\n\nBecause a is pointing to a NewClass object, a.method1() will execute NewClass’s method1() even though a is a SomeClass object.\n\n\n\n\n\nPolymorphism\n\nConsider the following program:\n\n  SomeClass a; // superclass reference variable\n  // Use superclass variable to access overridden method in superclass\n  a = new SomeClass(); // refer superclass object\n  a.method1(); // calls SomeClass.method1()\n  // Use superclass variable to access overridden method in subclass\n  a = new NewClass(); // refers subclass object\n  a.method1(); // class NewClass.method1()\n\nThe same expression a.method1() invokes different methods\n:::{#nte-polymorphism .callout-note} ## Polymorphism The phenomenon that the same expression (program code) can result in different actions. Polymorphism is caused by using a superclass reference variable to access overridden members in the superclass and their subclasses and late binding. :::\n\nA reverse case: a superclass object may perform fewer actions than a subclass object.\n\nTherefore, it is illegal to use a subclass reference variable to access members in a superclass object."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#application-of-polymorphism-selection-sort-algorithm",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#application-of-polymorphism-selection-sort-algorithm",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Application of Polymorphism: Selection Sort Algorithm",
    "text": "Application of Polymorphism: Selection Sort Algorithm\n\n\n\n\n\n\nNote 3: Sorting an array\n\n\n\nRe-arrange the values in an array so that the values are ordered.\n\n\n\nIn our discussion, we will sort the array in ascending order.\nThere are many array sorting algorithms, but we will first examine the selection sort algorithm.\n\nSelection sort finds the smallest number in the list and swaps it with the first element.\nIt then finds the smallest number remaining and swaps it with the second element.\nAnd so on, until only a single number remains (i.e., the last number in the list)\n\npublic static void selectionSort(int[] list) {\nfor (int i = 0; i &lt; list.length-1; i++) {\n  // Find the minimum in the list[i...list.length-1]\n  int min      = list[i]; // Assume the first element is min\n  int minIndex = i;       // Index where min is found\n  for (int k = minIndex+1; k &lt; list.lenght; k++) {\n    if (list[k] &lt; min) {  // Find a smaller element\n      min      = list[k]; // Update min value\n      minIndex = k;       // Update its index\n    }\n  }\n  // Swap list[i] with list[minIndex] if necessary\n  if (minIndex != i) {\n    // Swap list[minIndex] and list[i]\n    // Standard exchange alg\n    int help       = list[minIndex];\n    list[minIndex] = list[i];\n    list[i]        = help;\n  }\n}\n}\nDue to polymorphism, we can change the selection sort algorithm for integers to Circle, Rectangle, and even GeometricObject objects.\n\nIn order to do so, the superclass object must provide all the necessary actions used in the selectionSort() algorithm.\nTo be more specific, that is why we have defined getArea() { return 0 } in the GeometricObject previously.\n\npublic static void selectionSort(GeometricObject[] list) {\n  for (int i = 0; i &lt; list.length-1; i++) {\n    GeometricObject min = list[i]; \n    int minIndex        = i; \n    for (int k = minIndex+1; k &lt; list.lenght; k++) {\n      if (list[k].getArea() &lt; min.getArea()) {  \n        min      = list[k];\n        minIndex = k;\n      }\n    }\n    if (minIndex != i) {\n      GeometricObject help = list[minIndex];\n      list[minIndex]       = list[i];\n      list[i]              = help;\n    }\n  }\n}\npublic static void mian(String[] args) {\n  GeometricObject[] myList = new GeometricObject[4];\n  myList[0] = new Circle(\"red\", 2);\n  myList[1] = new Rectangle(\"blue\", 1, 1);\n  myList[2] = new Circle(\"white\", 5);\n  myList[3] = new Rectangle(\"black\", 4, 4);\n  selectionSort(myList)l\n  for (int i = 0; i &lt; myList.length; i++) {\n    System.out.println(myList[i]);\n  }\n}\nSummary\n\nA common technique to generalize code is to write methods with a superclass type as parameter type.\nSuch a method can receive objects of any subclass type as argument.\nRequirement:\n\nThe superclass type must provide all the actions necessary to code the method\n\nJava provides an interface mechanism that is similar to the inheritance mechanism for defining superclass type and subclass type relationship.\nUsing this interface mechanism, we can make a superclass type that can unite the String, the Circle, and the Rectangle classes"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#exception-handling-and-polymorphism",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#exception-handling-and-polymorphism",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Exception Handling and Polymorphism",
    "text": "Exception Handling and Polymorphism\n\nThe exception types in Java are also organized as an inheritance hierarchy. The root type is Exception\nWe can catch more general exceptions using types higher up in the exception hierarchy. java     public static void main(String[] args) {       int[] a = new int[10];       try {         a[99] = 1;       } catch (Exception e) { // higher up.         System.out.println(e);       }     }\n\nUse Exception, we will catch all types of exceptions\n\nWe can use multiple catch clauses, but the more specific exceptions should come first. java     public static void main(String[] args) {       int[] a = new int[10];       try {         if (Math.random() &lt; 0.5) {           a = null;         }         a[99] = 1;       } catch (ArrayIndexOutOfBoundsException e) {         System.out.println(e);       } catch (Exception e() {         System.out.println(e);       }     }"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#upcasting-downcasting-and-instanceof-operator",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#upcasting-downcasting-and-instanceof-operator",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Upcasting, Downcasting, and instanceof operator",
    "text": "Upcasting, Downcasting, and instanceof operator\n\n\n\n\n\n\nNote 4: Upcasting\n\n\n\nCasting (converting) a subclass reference into a superclass reference. - Upcasting is a safe operation because we can make fewer requests using a superclass variable than using a subclass variable.\n\n\n\n\n\n\n\n\nNote 5: Downcasting\n\n\n\nCasting (converting) a superclass reference into a subclass reference. - Downcasting is an unsafe operation because we may make an illegal request using a subclass variable.\n\n\n\nUnder some situations, downcasting can be safe and necessary:\n\nWe first perform an upcasting operation\nLater, we want to perform an action defined in the subclass\n\n\n\n\n\n\n\n\nTip 6: To Perform a Safe Downcasting Operation\n\n\n\n\n\npublic static void main(String[] args) {\n  GeometricObject a = new Circle(\"red\", 1); // Upcasting\n  System.out.println(a.getArea()); // safe\n  // System.out.println(a.getRadius()); // illegal -- getRadius() is not defined in GeometricObject\n  Circle b;\n  b = (Circle) a; // Explicit upcasting\n  System.out.println(b.getRadius()); // allowed\n}\n\n\n\n\nWe can also write similar codes for downcasting a GeometricObject object to a Rectangle object. However, how can we write a program to cast the superclass variable references to a subclass variable of non-specific subclass?\nThe instanceof boolean condition:\n\nobjectRefVar instanceof className;\n// returns true if the object referred to by objectRefVar\n// is an object of className type or a subclass type of\n// className. Otherwise, returns false\n\nUsing the instanceof, we can solve the problem:\n\npublic static void main(String\\[\\] args) { \n  GeometricObject a; if (Math.random() \\&lt; 0.5) { \n    a = new Circle(\"red\", 1); \n  } \n  a = new Rectangle(\"blue\", 2, 1);\n       \n  if (a instanceof Circle) {\n    Circle b = (Circle) a; // downcast to a circle\n    System.out.println(b.getRadius();)\n  } else if (a instanceof Rectangle) {\n    Circle b = (Rectangle) a; // downcast to a rectangle\n    Syste.out.println(b.getWidth());\n    Syste.out.println(b.getHeight());\n  } else {\n    System.out.println(\"Invalid subclass type\");\n  }\n}"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#hiding-variables-and-multi-inheritance",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#hiding-variables-and-multi-inheritance",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Hiding Variables and Multi-Inheritance",
    "text": "Hiding Variables and Multi-Inheritance\n\nIf a subclass defines a variable x with the same name as its superclass:\n\nthe name x will refer to the variable in the subclass:\n\nThe variable x in the subclass will overshadow (hide) the variable in the superclass.\n\nThe variable x in the superclass can be accessed in the subclass using super.x (or through a non-overridden method)\nHowever, it’s a terrible idea to override variables.\n\nMultiple-Inheritance\n\nJava allows a class to inherit from only one superclass, while other languages (such as C++) can inherit from multiple class and made things very complicated.\nJava does implement some features of multiple inheritance through interface:\n\nA class can have multiple parent interfaces\nBut these parent interfaces must be completely empty (=no variables and contains only method declarations)"
  },
  {
    "objectID": "notes/cs171/04-Packages/Packages.html",
    "href": "notes/cs171/04-Packages/Packages.html",
    "title": "Lecture 3 Packages",
    "section": "",
    "text": "Why do programming languages provide different accessibilities (i.e. private and public qualifiers):\n\nA large computer program has many methods stored in different classes\nMethods defined inside a class are used to solve the same problem\nMethods defined inside different classes usually do not solve the same problem\nA common cause for errors is accidental update of variable(s) by a method in a different class\nLimiting access to variables (with the private qualifiers) will reduce accidental update of variable(s) by a method from another class\n\nJava packages:\n\nSome problems are too complex that they cannot be solved by methods inside one single class\n\nWe may need to write multiple classes to solve such complex problems\n\nPrograms will run more efficiently if they can access variables directly\nI.e., Getter (getRadius()) and setter (setRadius()) will slow down a program\n\n\n\n\n\n\n\n\n\n\nNote 1: Package\n\n\n\nPackage in Java is used to organize multiple classes that cooperate and perform similar tasks\n\n\n\nIt facilitates (=make it easier) the cooperation: - Java can allow methods defined in classes inside the same package to access each other members (variables and methods) directly\nExample on using a package\n\npackage p1;\npublic class C1{\n    public int x1;\n           int x2; // Default (= package) access modifier\n           // \n    private int x3;\n\n    public void m1() { }\n           void m2() { } // Default (= package) access modifier\n    private void m3() { }\n}\n\nThe numbers x2 and m2() has no access modifier. In that case, they will be assigned with the default access modifier.\n\nA member with the default access can be accessed from methods in classes belong to the same package. - Class in a same package cooperate to perform a task\nA member with the default access is not accessible from methods in classes belong to a different package. - Class in different packages do not cooperate to perform a task\nSee Demo.java\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "",
    "text": "In the inheritance hierarchy (tree), classes become more specific and concrete with each new subclass. If we move from a subclass back up to a superclass, the classes become more general and less specific - i.e., more abstract.\nImportant class design principle:\n\nthe superclass contains common features of all subclasses\nSometimes, a common action (method) is not well-defined:\n\nWe know what the action is, but we cannot be specific about it.\n\nSometimes, a superclass is so abstract that it cannot be used to create any specific instances.\n\n\n\n\n\n\n\n\nNote 1: Abstract Class\n\n\n\nAn abstract class is a class that cannot be instantiated. That is, we cannot create instances of an abstract class.\n\n\npublic abstract class className {\n    // same as a normal class\n}\n\nAny class can be defined as abstract.\nWe can define (reference) variables of an abstract class type\nWe can also extend (derive a subclass from) an abstract class\nTherefore, an abstract class can serve as the superclass for polymorphic methods.\n\n\n\n\n\n\n\nNote 2: Abstract Methods\n\n\n\nAn abstract method consists of only the method declaration without the method body. The method declaration consists of only the method header (data types) information.\n\n\n\nDeclarations are used to convey data type information to the Java compiler.\n\npublic abstract returnType methodname(params);\n\nSee AbstractSort.java\nRelationship between abstract classes and abstract methods:\n\nabstract method:\n\nAn abstract method is an incomplete method. It cannot be executed (because it has no method body)\n\nRule: A class that contains an abstract method must be defined as an abstract class.\n\nThis is to prevent users from instantiating objects that contains incomplete methods\n\nSubclasses of abstract classes:\n\nA subclass that do not define all the abstract methods must be defined as an abstract class\nOtherwise, the class can be defined as a normal class.\n\n\nAn abstract class cannot be defined as a final class\n\nAn abstract class cannot be instantiated, so it needs to be extended (i.e., not final) into a concrete class to become instantiable.\nSimilarly, we can also not have abstract final methods. This is because an abstract method is incomplete (has no method body) and must be overridden (not final) so the method can become concrete.\nA class that contains an abstract method must be defined as an abstract class\n\nSome interesting features:\n\nA class can be abstract even if its superclass is non-abstract.\nAn abstract subclass can override a non-abstract method from its superclass with an abstract method.\n\nWhen the implementation of the method in the superclass becomes invalid in the subclass.\n\n\nPractical use of abstract classes:\n\nWhen we are unsure of how a method should be defined/implemented for that class.\nWhen we do not want objects of that type being instantiated (and used) - even when the class has no abstract methods."
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-abstract-classes-and-abstract-methods",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-abstract-classes-and-abstract-methods",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "",
    "text": "In the inheritance hierarchy (tree), classes become more specific and concrete with each new subclass. If we move from a subclass back up to a superclass, the classes become more general and less specific - i.e., more abstract.\nImportant class design principle:\n\nthe superclass contains common features of all subclasses\nSometimes, a common action (method) is not well-defined:\n\nWe know what the action is, but we cannot be specific about it.\n\nSometimes, a superclass is so abstract that it cannot be used to create any specific instances.\n\n\n\n\n\n\n\n\nNote 1: Abstract Class\n\n\n\nAn abstract class is a class that cannot be instantiated. That is, we cannot create instances of an abstract class.\n\n\npublic abstract class className {\n    // same as a normal class\n}\n\nAny class can be defined as abstract.\nWe can define (reference) variables of an abstract class type\nWe can also extend (derive a subclass from) an abstract class\nTherefore, an abstract class can serve as the superclass for polymorphic methods.\n\n\n\n\n\n\n\nNote 2: Abstract Methods\n\n\n\nAn abstract method consists of only the method declaration without the method body. The method declaration consists of only the method header (data types) information.\n\n\n\nDeclarations are used to convey data type information to the Java compiler.\n\npublic abstract returnType methodname(params);\n\nSee AbstractSort.java\nRelationship between abstract classes and abstract methods:\n\nabstract method:\n\nAn abstract method is an incomplete method. It cannot be executed (because it has no method body)\n\nRule: A class that contains an abstract method must be defined as an abstract class.\n\nThis is to prevent users from instantiating objects that contains incomplete methods\n\nSubclasses of abstract classes:\n\nA subclass that do not define all the abstract methods must be defined as an abstract class\nOtherwise, the class can be defined as a normal class.\n\n\nAn abstract class cannot be defined as a final class\n\nAn abstract class cannot be instantiated, so it needs to be extended (i.e., not final) into a concrete class to become instantiable.\nSimilarly, we can also not have abstract final methods. This is because an abstract method is incomplete (has no method body) and must be overridden (not final) so the method can become concrete.\nA class that contains an abstract method must be defined as an abstract class\n\nSome interesting features:\n\nA class can be abstract even if its superclass is non-abstract.\nAn abstract subclass can override a non-abstract method from its superclass with an abstract method.\n\nWhen the implementation of the method in the superclass becomes invalid in the subclass.\n\n\nPractical use of abstract classes:\n\nWhen we are unsure of how a method should be defined/implemented for that class.\nWhen we do not want objects of that type being instantiated (and used) - even when the class has no abstract methods."
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-interfaces",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-interfaces",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "Introduction to Interfaces",
    "text": "Introduction to Interfaces\n\n\n\n\n\n\nNote 3: Interface\n\n\n\nAn interface can be used to define common behavior for any classes (including unrelated classes). It is a similar mechanism as inheritance for unrelated class that share some behaviors (methods)\n\n\n\nAn interface is an abstract class-like construction that contains only\n\nmethod declarations and\nconstants (static and final)\n\nWe can define interface variables but cannot instantiate objects with an interface (just like an abstract class)\n\npublic interface myInterface {\n    public abstract void myMethod(); // abstract is optional\n    // other methods\n}\n\nAn interface cannot have a constructor method. We cannot create objects of an interface type (similar to an abstract class)\nWe can define variables of an interface type (to achieve polymorphism): myInterface a;\nWe implement an interface with an implementation class:\n\npublic class myClass implements myInterface {\n    // must override all methods decleared in the interface\n    public void myMethod(){\n        System.out.println(\"Running myMethod() in myClass\");\n    }\n}\n\nThe implementation class must override all methods declared in an interface.\n\n\n\n\n\n\n\nTip 1: Example to Use an Interface\n\n\n\n\n\n\nWe cannot instantiate an object with an interface type\nHence, we always upcast an object of its implementation class and assign it to an interface variable.\n\nWe upcast an object if the class implements the interface\nan interface is a superclass (of unrelated objects)\nSee InterfaceSort.java\n\n\n\n\n\n\nThe Comparable interface of the Java library\n\nIt is the superclass of all objects that can be compared.\n\npublic interface Comparable&lt;E&gt; {\n  public int compareTo(E o);\n}\n\nThe syntax &lt;T&gt; is called a generic type in Java.\n\n\n\n\n\n\n\n\nTip 2: Example to Use the Comparable Interface\n\n\n\n\n\npublic class Circle extends GeometricObject implements Comparable&lt;Circle&gt; {\n    private double radius;\n    // other method omitted\n    /**\n     * Arrays.sort() will only work with Comparable objects\n     * The Circle class must implement the Comparable interface\n     * in order to use Array.sort()\n     */\n    public int compareTo(Circle other) {\n        double diff = this.getArea() - other.getArea();\n        return (int) Math.signum(diff);\n    }\n}\n\n\n\n\nA class can inherit from only one class, but a class can implement multiple interfaces.\n\nEach interface defines a set of capabilities or “roles”.\nImplementing an interface allows a class to fulfill the role defined by an interface.\nTherefore: a class in java can fulfill multiple roles.\n\ninstanceof\n\nThe instanceof operator tells us whether a variable is a member of a class or an interface (i.e., an interface is similar to a class in Java)\n\nMethods with a default implementation in an interface\npublic interface InterfaceName {\n  public default returnType methodName(params) {\n      // method body\n  }\n}\n\nUsage: when the implementing class does not override a method with a default implementation, the Java compiler will use the default implementation as the overriding method.\n\nUnlike classes that can extend only 1 class, an interface can extend one or more interfaces\n\npublic interface Insurable extends Sellable, Transportable {\n    public int insuredValue();\n}\n\nThe interface Insurable will combine:\n\nAll methods in Sellable\nAll methods in Transportable\nThe insuredValue() method\n\n\n\n\n\n\n\n\n\nAbstract Class\nInterface\n\n\n\n\nCan have constructors, instance variables, constants, abstract methods, and non-abstract methods\nCan only have abstract methods and constants\n\n\nIs extended by a subclass that may implement the abstract methods, but does not have to. (If the subclass does not implement all abstract methods, it must be defined as an abstract class too)\nIs implemented by a subclass that must implement all the abstract methods"
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#review-of-oop-concepts",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#review-of-oop-concepts",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "Review of OOP Concepts",
    "text": "Review of OOP Concepts\n\nA class, is like a definition of a data type in Java.\nAn instance of an object of a given class is created (instantiated) using a constructor and the new operator.\nObject instances in Java are accessed through reference variables.\nA subclass can extend a superclass and use its methods and instance variables through inheritance and polymorphism.\nAbstract classes can contain 0 or more abstract methods. Classes containing at least one abstract method must be abstract. Abstract classes can not be used to instantiate objects. Abstract classes are extended by a subclass that defines the abstract methods.\nInterfaces contain only abstract methods and constants and provides a template for another class to implement all of the methods declared in the interface."
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html",
    "href": "notes/cs171/07-Generics/Generics.html",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "",
    "text": "Note 1: Generic class\n\n\n\nA generic class is a parameterized class where the parameters are always object types.\n// T1, T2, ... are object type parameters\npublic class ClassName&lt;T1, T2, ...&gt; {\n    // we can use T1, T2, ... as type specifier here\n}\n\n\npublic class GenericStroe&lt;T&gt; {// T is the type parameter\n    private T data; // variable of the T type\n    public GenericStore(T data) {\n        this.data = data;\n    }\n    public T getData() { // return T type variable\n        return this.data;\n    }\n}\n\nThe Java compiler will remember the places where the generic type parameter T are used.\nThe generic type parameter T tells the Java compiler to place the correct cast operation at some result before using it.\nWhen the parameter type is &lt;T&gt;, the Java compiler will replace every occurrence of &lt;T&gt; by Object.\nWhen we define a variable of a generic class, we specify the object type parameter along with the class name:\n\nGenericsStore&lt;String&gt; a = new GenericsStore&lt;String&gt;();\nGenericsStore&lt;Integer&gt; b = new GenericsStore&lt;Integer&gt;();\n\nThe result will be:\n\nThe Java compiler will remember the parameter type of each variable, and\nInsert the proper casting operation before using the value returned by their methods.\n\nThe parameters of a generic class must be object (reference) types\n\nWe cannot define generic class variables using primitive types:\n\n  GenericsStore&lt;int&gt; a = new GenericsStore&lt;int&gt;(); // Illegal!\n\nUse a wrapper class if we need to use a primitive type.\n\nWe can use a short hand notation to define a generic class variable: java       GenericsStore&lt;Integer&gt; a = new GenericsStore&lt;&gt;();\n\nThe Java compiler can infer the second parameter\n\nCommonly parameter names used are: T (Type), E (Element), K (Key), and V (Value)"
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html#intro-to-generic-classes",
    "href": "notes/cs171/07-Generics/Generics.html#intro-to-generic-classes",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "",
    "text": "Note 1: Generic class\n\n\n\nA generic class is a parameterized class where the parameters are always object types.\n// T1, T2, ... are object type parameters\npublic class ClassName&lt;T1, T2, ...&gt; {\n    // we can use T1, T2, ... as type specifier here\n}\n\n\npublic class GenericStroe&lt;T&gt; {// T is the type parameter\n    private T data; // variable of the T type\n    public GenericStore(T data) {\n        this.data = data;\n    }\n    public T getData() { // return T type variable\n        return this.data;\n    }\n}\n\nThe Java compiler will remember the places where the generic type parameter T are used.\nThe generic type parameter T tells the Java compiler to place the correct cast operation at some result before using it.\nWhen the parameter type is &lt;T&gt;, the Java compiler will replace every occurrence of &lt;T&gt; by Object.\nWhen we define a variable of a generic class, we specify the object type parameter along with the class name:\n\nGenericsStore&lt;String&gt; a = new GenericsStore&lt;String&gt;();\nGenericsStore&lt;Integer&gt; b = new GenericsStore&lt;Integer&gt;();\n\nThe result will be:\n\nThe Java compiler will remember the parameter type of each variable, and\nInsert the proper casting operation before using the value returned by their methods.\n\nThe parameters of a generic class must be object (reference) types\n\nWe cannot define generic class variables using primitive types:\n\n  GenericsStore&lt;int&gt; a = new GenericsStore&lt;int&gt;(); // Illegal!\n\nUse a wrapper class if we need to use a primitive type.\n\nWe can use a short hand notation to define a generic class variable: java       GenericsStore&lt;Integer&gt; a = new GenericsStore&lt;&gt;();\n\nThe Java compiler can infer the second parameter\n\nCommonly parameter names used are: T (Type), E (Element), K (Key), and V (Value)"
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html#intro-to-generic-methods",
    "href": "notes/cs171/07-Generics/Generics.html#intro-to-generic-methods",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "Intro to Generic Methods",
    "text": "Intro to Generic Methods\n\nSyntax to define a generic (parameterized) method\n    public static &lt;T1, T2, ...&gt; returnType methodName(params) {\n      // method body\n    }\n    ```\n-   We can use the type parameters `T1, T1, ...` to declare parameter variables, local variables, and the return type of the method.\n``` java\npublic static &lt;T&gt; void print(T[] list) {\n  for (int i = 0; i &lt; list.length; i++) {\n      System.out.println(list[i]);\n  }   \n}\n\nThe generic method will be made specific (with a data type) in the invocation.\n\nWhen we write a generic method, the Java compiler will replace every occurrence of &lt;T&gt; by Object and will remember that list[] is a parameterized class variable.\n\nWhen the print() method is used, the Java compiler will insert the appropriate casting operator\n\nSyntax to invoke a generic (parameterized) method:\n\n    Classname.&lt;T1, T2, ...&gt;methodName(arguments)"
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html#bounded-and-unbounded-parameter-type",
    "href": "notes/cs171/07-Generics/Generics.html#bounded-and-unbounded-parameter-type",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "Bounded and Unbounded Parameter Type",
    "text": "Bounded and Unbounded Parameter Type\n\nAn unbounded generic type parameter T is specified as &lt;T&gt; or &lt;T extends Objects&gt;\n\nWe can use any object (reference) type to make the parameter type T into a specific type.\nWhen an unbounded generic type parameter T is used in a generic class definition, the type parameter &lt;T&gt; is replaced by Object.\n\nWhen Object is inappropriate as the parent class: Object does not have certain required methods used in the code.\nA bounded generic type parameter T is specified as &lt;T extends SuperClass&gt;\n\nIn this way, we can only use a subtype of a superclass to make T into a specific type.\nWhen a bounded generic type parameter T is used in a generic class definition, the type parameter &lt;T&gt; is replaced by the bounding type, instead of Object.\n\nThe use of bounded type parameter is necessary when we have used a method in the code that is not defined in the Object class."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html",
    "href": "notes/cs171/02-Review/Review.html",
    "title": "Lecture 1 Introduction & Review",
    "section": "",
    "text": "Note 1: Algorithm\n\n\n\nA method for solving a problem expressed as a sequence of steps that is suitable for execution by a computer(machine).\n\n\nDifferent ways to express algorithms:\n\nNatural languages (bad - ambiguous)\nFlow charts (good for conceptualization of the algorithm)\nPseudo code (good for algorithm development)\nProgramming languages (good for communicating the algorithm to a machine because it’s unambiguous)\n\n\n\n\n\n\n\nNote 2: Data structure\n\n\n\nA way to organize (insert, delete, and retrieve) the data used by an algorithm\n\n\n\n\n\n\n\n\nTip 1: Example of a data structure\n\n\n\n\n\nArrays\n\n\n\nEvery data structure has its strengths and its weaknesses:\n\nArray: The data is stored in consecutive array elements & The array elements are accessed efficiently using an index.\n\nStrength: efficient (low) storage cost\nWeakness: not dynamic (cannot increase in size easily)\n\n\nMetrics used to measure the goodness of algorithms:\n\nRunning time: how long does it take for the program to finish\nStorage requirement: how much memory does the program use to store its information."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#introduction",
    "href": "notes/cs171/02-Review/Review.html#introduction",
    "title": "Lecture 1 Introduction & Review",
    "section": "",
    "text": "Note 1: Algorithm\n\n\n\nA method for solving a problem expressed as a sequence of steps that is suitable for execution by a computer(machine).\n\n\nDifferent ways to express algorithms:\n\nNatural languages (bad - ambiguous)\nFlow charts (good for conceptualization of the algorithm)\nPseudo code (good for algorithm development)\nProgramming languages (good for communicating the algorithm to a machine because it’s unambiguous)\n\n\n\n\n\n\n\nNote 2: Data structure\n\n\n\nA way to organize (insert, delete, and retrieve) the data used by an algorithm\n\n\n\n\n\n\n\n\nTip 1: Example of a data structure\n\n\n\n\n\nArrays\n\n\n\nEvery data structure has its strengths and its weaknesses:\n\nArray: The data is stored in consecutive array elements & The array elements are accessed efficiently using an index.\n\nStrength: efficient (low) storage cost\nWeakness: not dynamic (cannot increase in size easily)\n\n\nMetrics used to measure the goodness of algorithms:\n\nRunning time: how long does it take for the program to finish\nStorage requirement: how much memory does the program use to store its information."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---computer-architecture",
    "href": "notes/cs171/02-Review/Review.html#review---computer-architecture",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Computer Architecture",
    "text": "Review - Computer Architecture\n\nThe smallest unit of Computer Memory: bit\n\nComputers use memory devices built with electronics.\nThe smallest memory device used by the computer works like a switch. It can be in one of the 2 states:\n\nOff state (state 0)\nOn state (state 1)\n0 and 1 are called binary digits\n\nThe smallest memory device is called a bit (=binary digit)\nA row on \\(n\\) bits can be in one of \\(2^n\\) states: each switch can be in 2 states, and so the total number of combinations is \\(2\\times2\\times2\\times\\cdots\\times2=2^n\\)\nByte memory = 8 bits = a memory device that can retain (=remember) 8 binary digits. Since \\(2^8=256\\), each byte can store one of the 256 possible patterns of binary numbers.\nThough humans are very flexible in storing data (can use many different methods), computers can only store data/information as binary numbers.\n\n\n\nMemory address and Memory content\n\nEach memory cell is identified by a unique address (which is a number).\nEach memory cell stores a number (that is the data/information stored by the computer)."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---variables-in-java",
    "href": "notes/cs171/02-Review/Review.html#review---variables-in-java",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Variables in Java",
    "text": "Review - Variables in Java\n\nWhat happens inside the computer when we define a variable int a:\n\nThe computer will find some used memory cells and mark them as used (aka: allocate memory)\nThe computer equates(=records) the name a to the memory location of the reserved cells.\n\nEach variable has a data type\n\nThe data type specifies the kind of information.\nEach kind of information has its own way of representation. The way of representation is called a code.\n\nEncoding method of a data type:\n\nInformation of a data type are represented by binary numbers.\nThe encoding method defines the way to interpret a binary number.\n\nData type provide the context to interpret a number and obtain the meaning of the number.\n\nSee datatype.java for an example.\n\nJava’s primitive data types:\n\n\n\n\nData type\nEncoding method\n\n\n\n\nbyte\n2’s complement encoding using 8 bits\n\n\nshort\n2’s complement encoding using 16 bits\n\n\nint\n2’s complement encoding using 32 bits\n\n\nlong\n2’s complement encoding using 64 bits\n\n\nfloat\nIEEE 754 encoding using 32 bits\n\n\ndouble\nIEEE 754 encoding using 64 bits\n\n\nchar\nUnicode encoding using 16 bits\n\n\nboolean\nEnumeration encoding using 0=false and 1=true\n\n\n\n\nBesides the primitive data types, all other data types in Java are reference data types:\n\nReference: A reference in computer science is a memory address\nReference data type: A variable of a reference data type stores a memory address\n\nPrimitive and reference data types are stored differently:\n\nThe variable of primitive data types contains a value of that data type.\nThe variable of reference data types contains a reference to the location where the object is stored."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---programming-language",
    "href": "notes/cs171/02-Review/Review.html#review---programming-language",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Programming Language",
    "text": "Review - Programming Language\n\n\n\n\n\n\nNote 3: Programming Language\n\n\n\nAn artificial language designed to convey commands unambigously to a machine.\n\nA programming language has a set of syntax rules to construct commands.\n3 types of commands/statements in a procedural programming language:\n\nAssignment statement - Selection statement: if, if-else\nLoop statement: while, for, do-while\n\nThese 3 types of statements are necessary and sufficient to make a programming language Turing-complete (meaning the machine can solve any computational problem given enough time and memory, no matter how complex).\n\n\n\n\n\n\n\n\n\nNote 4: Operator\n\n\n\nA symbol that represents an operation.\n\n\n\n\n\nAssignment\nArithmetic\nRelational\nLogical\nSpecial\n\n\n\n\n=\n\n==\n&&\n++\n\n\n+=\n+\n!=\n||\n--\n\n\n-=\n-\n&lt;\n!\n\n\n\n*=\n*\n&lt;=\n\n\n\n\n/=\n/\n&gt;\n\n\n\n\n%=\n%\n&gt;=\n\n\n\n\n\n\n\n\n\n\n\nNote 5: Operand\n\n\n\nThe value used in an operation.\n\nAn operator performs an operation on its operands and produce some result value.\n\n\n\n\n\n\n\n\n\nNote 6: Expression\n\n\n\nA combination of one or more operators and operands that performs a computation.\n\nAn expression can be built up from other expressions.\n\n\n\ncore = score - 10 * lateDays;\n\nConsists of the arithmetic expression 10 * lateDays\nwhich itself is an operand of the arithmetic expression score - •\nwhich is an operand of the assignment expression score = •\n\n\n\n\n\n\n\nNote 7: Pre-operators and Post-operators\n\n\n\n\nPre-operators preforms the operation first and will return the new value of the variable.\nPost-operators performs the operation later and returns the old value of the variable.\n\n\n\nx = 4;\ny = ++x;   &lt;===&gt;   x = x + 1; y = x; (PRE increment)\n\nResult: x = 5  y = 5\nx = 4;\ny = x++;   &lt;===&gt;   y = x; x = x + 1; (POST increment)\n\nResult: x = 5  y = 4\n\n\n\n\n\n\nNote 8: Statement\n\n\n\nA command issued to the computer to do something.\n\nStatement is the unit of execution in a programming language.\nIn Java, a statement must be contained inside some method.\n\n\n\n\nAssignment statement:\n\nvariable = expression;\n\nx = 4; // Store the value 4 in variable x\nx = x + 1; // Read the value in variable x, add 1 to it, then store result in variable x\n\nVariables on the RHS of the = operator are read/accessed.\nThe variable on the LHS of the = operator is written/updated\nif statement\n\nif (condition)\n  one-statement;\n\nif (conditon) {\n  statement1;\n  statement2;\n  ...\n}\n\nif-else statement\n\nif (condition)\n  one-statement;\nelse\n  one-statement;\n\nif (condition) {\n  statement1;\n  statement2;\n  ...\n} else {\n  statement3;\n  statement4;\n  ...\n}\n\nSwitch statement\n\nSwitch (integer-expression) {\n  case intVal1: statement1-1;\n                statement1-2;\n                ...\n                break;\n  case intVal2: statement2-1;\n                statement2-2;\n                ...\n                break;\n  ...\n  default: statementD-1; //optional clause\n           statementD-2;\n           ...\n           break;\n}\n\nwhile loop\n\nwhile (condition)\n  one-statement;\n   \nwhile (condition) {\n  statement1;\n  statement2;\n  ...\n}\n\nfor loop\n\nfor (init; term-cond; incr) {\n  statement1;\n  statement2;\n  ...\n}\n\nSee LoopTracing.java"
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---array",
    "href": "notes/cs171/02-Review/Review.html#review---array",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Array",
    "text": "Review - Array\n\nSyntax to define an array (reference) variable:\n\ndataType[] arrayRefVar; // Defines an array reference variable\n\nSyntax to create an array object\n\nnew dataType[N]; // Create an array of N elements\n\nProperties of an array in Java:\n\nAll elements in the array have the same data type.\nArray elements are stored consecutively in memory\n\nint[] A; // A is a reference variable\nA = new int[10];\n\nint[] A will allocate (reserve memory) a reference variable A.\nnew int[10] will allocate for an int[10] array (=40 bytes) and return its base address.\nA = will assign the return value to the variable A.\n\nCopy an array:\n\nMake a duplicate of an array where the duplicate contains the same data as the original\nUpdating array elements in the duplicate must not affect the data in the original array.\n\n public static void main(String[] args) {\n    double[] myList = {34, 15, 66, 7};\n    double[] myListCopy = new double[ myList.length ];\n\n    for ( int i = 0; i &lt; myList.length; i++)\n       myListCopy[i] = myList[i];\n } \nSee (CopyArray.java)[CopyArray.java].\nVariables of primitive data types (such as int, double, etc.) can be copied with an assignment. However, in Java, the assignment operation will not copy objects of non-primitive data types.\n\ndouble[] myList = {34, 15, 66, 7};\ndouble[] myListCopy;\n\nmyListCopy = myList;   // Does not copy an array object \n// ** This copies the reference in myList to myListCopy\n\nThe assignment myListCopy = myList will copy the reference in myList to the myListCopy variable.\nBecause myListCopy and myList refer to the same array object, updates made with myListCopy[i] will also affect myList[i] and vice versa. &gt; Alias: When a difference variable names can be used to reference the same variable, they are called aliases in computer science.\nSee Alias.java."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---methods",
    "href": "notes/cs171/02-Review/Review.html#review---methods",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Methods",
    "text": "Review - Methods\n\n\n\n\n\n\nNote 9: Methods\n\n\n\nMethods are used to encapsulate(=put in a capsule) a series of operations used to solve a complex problem.\n\nMethods allow programmers to work with higher level of abstraction.\n\nLow level of abstraction = when we can see a log of detail\nHigh level of abstraction = when we can see less detail and the big picture\n\nAbstraction is a commonly used technique to solve complex problems.\nComponents in a method definition\n\naccess specifier: public/private\nclass variable modifier: static\nreturn value data type: int/double/etc.\nmethod name\nparameter variables\nlocal variable\nreturn value\n\n\n\n\n/**\n * This method returns the summation of integers from the start integer to the end integer.\n * @param start the start integer\n * @param end the final integer\n * @return the summation\n */\npublic static int sum(int start, int end) {\n  int s = 0;\n  for (int i = start; i &lt;= end; i++) {\n      s += i;\n  }\n  return s;\n}\n\nInvoking a method: The values of the actual parameters(=arguments) are passed(=copied) to the parameter variables of the method.\nThe signature of a method = method name + data type of the parameters.\n\nJava uses the method signature to select which method to invoke.\nOverloaded method = when there are multiple method in the class with the same method name but different signatures.\n\npublic class Overload {\n public static void meth(int x) {\n    System.out.println(\"Running: meth(int x)\");\n }\n\n public static void meth(double x) {\n    System.out.println(\"Running: meth(double x)\");\n }\n\n public static void meth(int x, int y) {\n    System.out.println(\"Running: meth(int x, int y)\");\n }\n}\nAlso see Overload.java.\nParameter passing = conveying some information(=parameter) to a method.\nThe most commonly used parameter passing mechanisms are:\n\nPass-by-value: The value of the argument is passed(=assigned) to the parameter variable. The method will use the copy of the argument’s value in its computations.\nPass-by-reference: the address of the argument is passed(=assigned) to the parameter variable. The method will retrieve the value using the address in computations.\n\nOne key to remember: The parameter variables are local variables to the method. Arguments and parameter variables are different variables.\nJava always passes the arguments by-value to a method. However, because primitive typed variables and reference typed variables are stored differently, the outcome of the pass-by-value mechanism is different for primitive typed variables and reference typed variables.\n\nA primitive typed argument passed to a method cannot be modified:\n\nSee PassPrimitive.java.\n\nA reference typed argument passed to a method will be modified.\n\nSee PassReference.java."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---exception-handling",
    "href": "notes/cs171/02-Review/Review.html#review---exception-handling",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Exception Handling",
    "text": "Review - Exception Handling\n\nWhen a method execution encounters an error, the method would return an error code: See ErrorCode.java.\nIn newer programming languages, the method will “throw an exception” when ti encounters an error: See ThrowException.java.\nYou can text(=catch) for the “error code” (exception type) and execute a block when the error code is detected: See CatchException.java."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html",
    "title": "Lecture 7 Array Data Structure",
    "section": "",
    "text": "Searching:\n\nSearching is a very common task in computer programming.\nMany algorithms and data structures are invented to support fast searching.\n\nSearching arrays:\n\nArrays are often used to store a large amount of data.\nSearching is the process of looking for a specific element in an array.\nThere are two search techniques for arrays: linear search and binary search.\n\n\n\n\n\n\n\n\nThe Search Problem for Arrays\n\n\n\nFor a given search value key, find the index of the first array element that contains the search value key.\n\nReturn -1 when the key is not found in the array.\n\n\n\n\nLinear Search algorithm:\n\nThe linear search algorithm compares the search value key sequentially with each element in the array.\nThe linear search algorithm continues to do so until the key matches an element in the array or the array is exhausted without a match being found.\nIf a match is made, the linear search returns the index of the element in the array that matches the key.\nIf no match is found, the search returns -1.\n\n\n/**\n * The linear search algorithm to find key in the array list\n */ \npublic static int linearSearch(int[] list, int key) {\n    for (int i = 0; i &lt; list.length, i++&gt;) {\n        if (list[i] == key) {\n            return i;\n        }\n    }\n    // key is not found in list[]\n    return -1;\n}\n\nComplexity Analysis:\n\nBest case scenario: the first element in the array contains the search key. Running time = 1 step (iteration)\nWorst case scenario: array does not contain the search key. We run through the whole array. Running time = \\(N\\) steps.\nAverage case scenario: on average, we will probe half of the array elements. Running time = \\(\\dfrac{N}{2}\\) steps.\n\nBinary search is a more efficient (faster) search algorithm for arrays.\n\nFor binary search to work, the elements in the array must already be ordered.\n\nFor the presentation of the binary search, we assume that the array is in ascending order.\n\nThe binary search compares the key with the element in the middle of the array.\n\n\n/**\n * The binary search algorithm for arrays\n */\npublic static int binarySearch(int[] list, int key) {\n    int low = 0;\n    int high = list.length - 1;\n\n    while (low &lt;= high) {\n        int mid = (low + high) / 2;\n        if (list[mid] == key) {\n            return mid;\n        } else if (list[mid] &lt; key) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    // If key is not found in the list[]\n    return -1;\n} \n\nComplexity Analysis:\n\nBest case scenario: the middle element in the array contains the search key. Running time = 1 step (iteration).\nWorse case scenario: Suppose the binary search takes \\(k\\) iterations to complete, then \\(\\dfrac{N}{2^k}=1\\) (after halving \\(N\\) elements for \\(k\\) times, we get 1). Solving the equation, we get \\(k=\\log(N)+1\\). So, running time \\(\\approx\\log(N)\\) steps.\nAverage case scenario: it is very hard to estimate, but we can use the worse case scenario as an upper bound for the running time in average."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#linear-search-and-the-binary-search-algorithms-for-arrays",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#linear-search-and-the-binary-search-algorithms-for-arrays",
    "title": "Lecture 7 Array Data Structure",
    "section": "",
    "text": "Searching:\n\nSearching is a very common task in computer programming.\nMany algorithms and data structures are invented to support fast searching.\n\nSearching arrays:\n\nArrays are often used to store a large amount of data.\nSearching is the process of looking for a specific element in an array.\nThere are two search techniques for arrays: linear search and binary search.\n\n\n\n\n\n\n\n\nThe Search Problem for Arrays\n\n\n\nFor a given search value key, find the index of the first array element that contains the search value key.\n\nReturn -1 when the key is not found in the array.\n\n\n\n\nLinear Search algorithm:\n\nThe linear search algorithm compares the search value key sequentially with each element in the array.\nThe linear search algorithm continues to do so until the key matches an element in the array or the array is exhausted without a match being found.\nIf a match is made, the linear search returns the index of the element in the array that matches the key.\nIf no match is found, the search returns -1.\n\n\n/**\n * The linear search algorithm to find key in the array list\n */ \npublic static int linearSearch(int[] list, int key) {\n    for (int i = 0; i &lt; list.length, i++&gt;) {\n        if (list[i] == key) {\n            return i;\n        }\n    }\n    // key is not found in list[]\n    return -1;\n}\n\nComplexity Analysis:\n\nBest case scenario: the first element in the array contains the search key. Running time = 1 step (iteration)\nWorst case scenario: array does not contain the search key. We run through the whole array. Running time = \\(N\\) steps.\nAverage case scenario: on average, we will probe half of the array elements. Running time = \\(\\dfrac{N}{2}\\) steps.\n\nBinary search is a more efficient (faster) search algorithm for arrays.\n\nFor binary search to work, the elements in the array must already be ordered.\n\nFor the presentation of the binary search, we assume that the array is in ascending order.\n\nThe binary search compares the key with the element in the middle of the array.\n\n\n/**\n * The binary search algorithm for arrays\n */\npublic static int binarySearch(int[] list, int key) {\n    int low = 0;\n    int high = list.length - 1;\n\n    while (low &lt;= high) {\n        int mid = (low + high) / 2;\n        if (list[mid] == key) {\n            return mid;\n        } else if (list[mid] &lt; key) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    // If key is not found in the list[]\n    return -1;\n} \n\nComplexity Analysis:\n\nBest case scenario: the middle element in the array contains the search key. Running time = 1 step (iteration).\nWorse case scenario: Suppose the binary search takes \\(k\\) iterations to complete, then \\(\\dfrac{N}{2^k}=1\\) (after halving \\(N\\) elements for \\(k\\) times, we get 1). Solving the equation, we get \\(k=\\log(N)+1\\). So, running time \\(\\approx\\log(N)\\) steps.\nAverage case scenario: it is very hard to estimate, but we can use the worse case scenario as an upper bound for the running time in average."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#adding-or-deleting-elements-from-an-array.",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#adding-or-deleting-elements-from-an-array.",
    "title": "Lecture 7 Array Data Structure",
    "section": "Adding or Deleting Elements from an Array.",
    "text": "Adding or Deleting Elements from an Array.\n\nAdding an element at the end of an array\n\nThe array size is fixed after its creation.\nTo add a new element to the end of an array:\n\nCreate a new array with the 1 more element\nCopy the elements in the original array to the new array.\nCopy the new value in the last element of the new array.\nChange the array reference to point to the new array.\n\npublic static int[] addElement(int[] x, int e) {\n    int[] temp = new int[x.length + 1];\n    for (int i = 0; i &lt; x.length; i++) {// copying\n        temp[i] = x[i];\n    } \n    temp[temp.length - 1] = e;\n    return temp;\n}\n\nThe algorithm executes \\(\\texttt{x.length}+1\\) data copy statements per addition.\nDeleting the last element from an array.\n\nThe array size is fixed after its creation.\nTo delete the last element from an array:\n\nCreate a new array with the 1 less element.\nCopy all except the last elements in the original array to the new array.\nChange the array reference to point to the new array.\n\npublic static int[] deleteElement(int[] x) {\n    int[] temp = new int[x.lenght - 1];\n    for (int i = 0; i &lt; temp.length; i++) {\n        temp[i] = x[i];\n    }\n    return temp;\n}\n\nWe can delete an element at a different location with a similar algorithm.\nA better way to add and delete elements in arrays: Dynamic arrays (aka. ArrayList in Java). It consists of\n\nA (fixed size) array\nA count of the actual number of elements stored in the array.\nThe array is increased only when the add() operation encounters a full array.\nThe array is reduced when the occupancy drops below a certain threshold.\nInserting a new value will increase the count. If the array is not full, we do not need to increase its size.\nThe array is increased only when the add() operation encounters a full array.\n\nThe add() method will increase the array size by approximately twice the original size. This will avoid frequent copy operations.\n\nThe array is reduced when the occupancy drops below a certain threshold.\n\nA commonly used algorithm to implement dynamic array is array doubling:\ntemp = new int[2 * x.length];\nfor (int i = 0; i &lt; x.length; i++) {\n  temp[i] = x[i];\n}\nx = temp;\nThe ArrayList class in Java implements a dynamic (resizable) array\n\nTo use it, we import java.util.ArrayList;\nSyntax to define an ArrayList (reference) variable:\n\nArrayList&lt;ObjectType&gt; varName\n\nSyntax to create an ArrayList object\n\nnew ArrayList&lt;Object Type&gt; ();\n\nThe ArrayList object will start with an array of limited size (about 10).\n\nSee DynamicArray.java\n\n\nCommonly used methods in the ArrayList class\n\nsize(): returns the actual number of elements in the ArrayList\ntoString() returns a String representation of all elements stored in the ArrayList\nadd(E e): appends the element e to the end of the ArrayList (E is the declared data type of the ArrayList elements)\nadd(int index, E elem): inserts the element e at index index and shifts and subsequent items to the right\nremove(int index): removes the element at index index and shifts all remaining items to the left.\nget(int index): returns the element stored at the index index\nset(int index, E elem): replaces the element at index index with the element elem\nIf the element at the index does not exist, get() and set() will throw IndexOutOfBoundsException.\n\nIterating through an ArrayList:\n\nUse a regular for-loop and get(index):\n\n  for (int i = 0; i &lt; numbers.size(); i++) {\n    System.out.println(numbers.get(i));\n  }\n\nUse a foreach loop:\n\n  for (int item: numbers) {\n    System.out.println(item);\n  }\n\nNote: a foreach loop cannot be used to update array elements\nUsing an iterator object:\n\nIterator&lt;Integer&gt; numItr = numbers.iterator();\nwhile (numItr.hasNext()) {\n  System.out.println(numItr.next());\n}\nJava Iterator interface and Iterable interface\n\nIterator is an interface (class containing all virtual methods) in java.util.Iterator.\nAn object that implements the Iterator interface must provide at least the following methods:\n\nhasNext(): returns true if the iteration has more elements\nnext(): return the next element in the iteration\n\nAn Iterator allows the user to iterate over the elements stored in an Iterable interface.\nAn object is Iterable if it implements the java.util.Iterable interface.\n\nIt must implement the iterator() method that returns a Iterator object.\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nArrayList\n\n\n\n\nPros\nUses less memory; can store primitive types; can be multi-dimensional\nSize is dynamic; easy to add/remove elements\n\n\nCons\nSize cannot change;hard to add/remove elements\nUses more memory; cannot store primitive types; can only be one-dimensional"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html",
    "title": "Lecture 2 Objects and Classes",
    "section": "",
    "text": "Class in Java contains variables and methods.\nThe real purpose of a class in Java is to implement/model an object that contribute to the solution of the problem.\nProgramming methodology before ~1980: use the modular programming technique to help build large-scale complex computer programs.\nToday’s methodology: use the object concept to build large-scale complex computer programs. This style of programming using object is called the Object-Oriented Programming (OOP)\nHow OOP help us write complex programs:\n\nAbstraction: OOP provides abstract classes to help reduce(=hide) details\nInheritance: allows existing code to be re-used.\nPolymorphism: allows existing code to be modified/enhanced.\nEncapsulation: prevents code in other classes from accessing/modifying important variables to localize debugging.\n\n\n\n\n\n\n\n\nNote 1: Object\n\n\n\nAn object represents an entity in the real world that can be distinctly identified.\n\n\n\nAn object has:\n\nA unique identity\nA state\nA behavior\n\n\n\n\n\n\n\n\nNote 2: State of an object\n\n\n\nThe state of an object (also known as its properties or attributes) is represented by data fields with their current values.\n\nA Java class represents the state/properties of objects using:\n\nThe instance variables inside a class\nEach object will have its own instance variables.\n\n\n\n\n\n\n\n\n\n\nNote 3: Behavior of an Object\n\n\n\nThe behavior of an object (also known as its actions) is defined by methods. To invoke a method on an object is to tell the object to perform an action.\n\nA Java class defines the behavior of objects using:\n\nThe instance methods inside a class\nAll objects of a class share the instance methods (because they have the same behavior).\n\n\n\n\n\nA class is used as a template(=description) to construct the object’s data fields and to define its methods:\n\nWhen we create objects of a class, Java will use the class definition to allocate the instance variables for that object.\nWhen you invoke some method on an object, Java will run the code in the method definition on the instance variables of the object.\nWe can create as many instances(=objects) of a class as we need:\n\nEach object will have its own properties(=instance variables).\nBut all objects will share the same actions(=instance methods)."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#introduction-to-object-oriented-programming-oop",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#introduction-to-object-oriented-programming-oop",
    "title": "Lecture 2 Objects and Classes",
    "section": "",
    "text": "Class in Java contains variables and methods.\nThe real purpose of a class in Java is to implement/model an object that contribute to the solution of the problem.\nProgramming methodology before ~1980: use the modular programming technique to help build large-scale complex computer programs.\nToday’s methodology: use the object concept to build large-scale complex computer programs. This style of programming using object is called the Object-Oriented Programming (OOP)\nHow OOP help us write complex programs:\n\nAbstraction: OOP provides abstract classes to help reduce(=hide) details\nInheritance: allows existing code to be re-used.\nPolymorphism: allows existing code to be modified/enhanced.\nEncapsulation: prevents code in other classes from accessing/modifying important variables to localize debugging.\n\n\n\n\n\n\n\n\nNote 1: Object\n\n\n\nAn object represents an entity in the real world that can be distinctly identified.\n\n\n\nAn object has:\n\nA unique identity\nA state\nA behavior\n\n\n\n\n\n\n\n\nNote 2: State of an object\n\n\n\nThe state of an object (also known as its properties or attributes) is represented by data fields with their current values.\n\nA Java class represents the state/properties of objects using:\n\nThe instance variables inside a class\nEach object will have its own instance variables.\n\n\n\n\n\n\n\n\n\n\nNote 3: Behavior of an Object\n\n\n\nThe behavior of an object (also known as its actions) is defined by methods. To invoke a method on an object is to tell the object to perform an action.\n\nA Java class defines the behavior of objects using:\n\nThe instance methods inside a class\nAll objects of a class share the instance methods (because they have the same behavior).\n\n\n\n\n\nA class is used as a template(=description) to construct the object’s data fields and to define its methods:\n\nWhen we create objects of a class, Java will use the class definition to allocate the instance variables for that object.\nWhen you invoke some method on an object, Java will run the code in the method definition on the instance variables of the object.\nWe can create as many instances(=objects) of a class as we need:\n\nEach object will have its own properties(=instance variables).\nBut all objects will share the same actions(=instance methods)."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#defining-a-class-creating-objects",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#defining-a-class-creating-objects",
    "title": "Lecture 2 Objects and Classes",
    "section": "Defining a Class & Creating Objects",
    "text": "Defining a Class & Creating Objects\npublic class Circle {\n    public double radius = 1; // The radius of this circle\n\n    public Circle() { } // constructor 1 for a circle object\n    public Circle(double newRadius) { // constructor 2 for a circle object\n        radius = newRadius;\n    }\n\n    public double getArea() { // return the area of this circle\n        return 3.14159 * radius * radius;\n    }\n\n    public void setRadius(double newRadius) { // set new radius for this circle\n        radius = newRadius;\n    }\n}\nWe use the Circle class to create two Circle objects:\npublic static void main() {\n    Circle circle1 = new Circle(); // Invokes Circle() to make this circle\n\n    Circle circle2 = new Circle(2); // Invokes Circle(double) to make this circle\n\n    double area1 = circle1.getArea(); // Tell circle1 to run getArea()\n    System.out.println(\"Area1: \" + area1);\n\n    double area2 = circle2.getArea(); // Tell circle2 to run getArea()\n    System.out.println(\"Area2: \" + area2);\n\n    circle1.setRaius(5); // Tell circle1 to run setRadius()\n\n    double area1 = circle1.getArea(); // Tell circle1 to run getArea()\n    System.out.println(\"Area1: \" + area1);\n}\n\nSee TestCircle.java and Cirlce.java\n\n\n\n\n\n\n\nNote 4: Unified Modeling Language (UML)\n\n\n\nA standardized modeling representation description of classes and objects.\n\n\n\nA Java class uses variables to define data fields (properties) of objects.\nA Java class uses methods to define the actions/behaviors of objects.\n\nMethods to define the actions of objects DO NOT have the static qualifier\n\nA class provides special method called constructors which are invoked only to create a new object.\n\nConstructors are designed to perform initializing actions, such as initializing the data fields of objects.\n\nA class that represents real world objects usually does not need a main() method. Without a main() method, such class cannot be run as a Java program.\n\nThough we may include a main() method in the class to test the methods, but it is preferred to write a separate class to do the testing.\n\nPreventing undesirable behavior in objects:\n\nThe Circle class implementation allows a user to access the object variables directly because we did not define radius to be private.\n\npublic class Circle {\n  public double radius = 1; // Then radius cannot be modified outside the class\n\n  public static void main() {\n      Circle circle1 = new Circle();\n      circle1.radius = 10; // changes the value of radius directlly\n  }\n}\n\nWe prevent direct access to variables in a class by using the private qualifier.\n\npublic class Circle {\n  private double radius = 1; // Then radius cannot be modified outside the class\n\n  public static void main() {\n      Circle circle1 = new Circle();\n      circle1.radius = 10; // complie error\n  }\n}"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#constructors-of-a-class",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#constructors-of-a-class",
    "title": "Lecture 2 Objects and Classes",
    "section": "Constructors of a Class",
    "text": "Constructors of a Class\n\n\n\n\n\n\nNote 5: Constructor\n\n\n\nConstructors are special methods in a class that is only invoked when an object is created using the new operator:\nClassName objVar = new ClassName(...);\n\nConstructors have 3 special properties:\n\nA constructor must have the same name as the class itself.\nConstructors do not have a return type - not even void.\nIf we include a void return type, then the method is not a constructor, but a behavior that the object can take.\n\nConstructors cannot be invoked like an ordinary method.\nLike regular methods, constructors can be overloads (i.e., multiple constructors can be defined with different signatures).\nRules on constructors and the default constructor:\n\nEvery class must have at least one constructor.\nIf a class does not have any constructor, then the Java compiler will automatically insert this constructor: className() { }. This constructor is called the default constructor.\nHowever, the Java compiler will not insert the default constructor if there is a constructor defined in the class."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#objects-as-reference-data-types",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#objects-as-reference-data-types",
    "title": "Lecture 2 Objects and Classes",
    "section": "Objects as Reference Data Types",
    "text": "Objects as Reference Data Types\nCircle  is a reference data type\ncircle1 is a reference variable\ncircle1 references (points to) a Circle object\n\nWe create variables to store the properties of a new object when we create the object\nThe behavior of an object (=program instructions) is stored when Java compiles the class definition.\nAn object’s member can refer to:\n\nA data field in the object\nA method in the object\n\nAfter an object is created, its data can be accessed, and its methods can be invoked using the dot operator.\nobjectRefVar.dataField  references a data field in the object\nobjectRefVar.method(arguments)  invokes a method on the object\nThe dot operator is also known as the object member access operator.\nWhy Java have reference typed variables and primitive typed variables?\n\nVariables of a primitive data type can only store 1 value but can be accessed quickly – such variables are mainly used in computations.\nObjects can have many data fields and can allow the programmer to represent complex things in the real world.\n\nObjects are mainly used for data representation\nAccessing to data in an object is slower (need 2 memory accesses)\n\n\nWe can access the member variable without using any reference variable:\n\nAn instance method is always invoked using an object reference variable: objectRefVar.method(arguments)\nThe variable objectRefVar is also passed to an instance method as an implicit (=hidden) parameter. The name of the implicit parameter is called this.\nSee Circle.java\n\nThis implicit parameter this is almost never necessary to write in a Java class. There is only 1 case that it is necessary:\n\nwhen a parameter variable has the same name as an instance variable in the class.\nSee Circle.java\n\nThe this keyword is can also be used to invoke another constructor of the same class."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#copying-objects",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#copying-objects",
    "title": "Lecture 2 Objects and Classes",
    "section": "Copying Objects",
    "text": "Copying Objects\n\nCopy an object means:\n\nMake a duplicate of an object where the duplicated object contains the same data as the original object.\nUpdating the instance variables in the duplicate object must not affect the values in the original object.\n\nOne way is to create a new object and then copy the data fields.\npublic static void main() {\n  Circle circle1 = new Circle(4);\n\n  // Make a COPY of circle1\n  Circle circle2 = new Circle();\n  circle2.radius = circle1.radius;\n}\n\nSee CircleCopy.java. This method only works when the data fields are defined in public.\n\nAnother way is through a copy constructor:\npublic class Circle{\n  private double radius = 1;\n  public Circle() { } // constructor for a circle object\n\n  public Circle(Circle c) { // copy constructor that copies circle c\n    radius = c.radius; \n  }\n}\n\nTo invoke the copy constructor:\n\npublic static void main() {\n  Circle circle1 = new Circle(4);\n  Circile circle2 = new Circle(circle1);\n}\n\nSee CircleCopy.java."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#arrays-of-objects",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#arrays-of-objects",
    "title": "Lecture 2 Objects and Classes",
    "section": "Arrays of Objects",
    "text": "Arrays of Objects\n\nSimilar to doubles and integers, we also have arrays of objects in Java. They are also defined in a similar way.\nIn other words, we can create a Circle object with new and assign it to an array element java     Circle[] circleArray = new Circle[10];     circleArray[0] = new Circle(4);\nHowever, an array of primitive variables is different from an array of reference variables.\n\nPrimitive:\n\nAfter creating an array of primitive variables, each array element can store a value.\nPrimitive type array variables (number[k]) contains values and is used in computations\n\nReference:\n\nAfter creating an array of reference variables, each array element can store a reference of an object.\nReference array variables (circleArray[k]) contains references and is used with the member selection operator . (the dot operator)."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#data-field-encapsulation",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#data-field-encapsulation",
    "title": "Lecture 2 Objects and Classes",
    "section": "Data Field Encapsulation",
    "text": "Data Field Encapsulation\n\nThe most important application of visibility(=accessibility) modifiers is: data field encapsulation.\n\n\n\n\n\n\n\nNote 6: Data Field Encapsulation Data Field Encapsulation is making data fields in an object inaccessible (=private) to other classes (which will disallow other classes from using the data fields directly).\n\n\n\n\n\n\n\nEncapsulation is important because\n\nIf a data field is not private, program written by other programmers can tamper with the data fields.\nWhen other programs use a data field in an object directly, changing the implementation of the object is more difficult.\n\nChanging the implementation of the object means change the way we present the properties of an object.\n\nFor example, we can use String to represent suit as {\"Spades\", \"Hearts\", \"Diamonds\", \"Clubs\"}. Meanwhile, we can also use int to represent it as {0 = \"Spades\", 1 = \"Hearts\", 2 = \"Diamonds\", 3 = \"Clubs}.\nWhen we use String, we can use card.suit.compareTo(\"Spades\") == 0 to test if the suit of the card is spade. However, if we change the implementation of card to int, the same code card.suit.compareTo(\"Spades\") == 0 will cause an error because we do not have a .compareTo() method for an integer.\n\n\n\nSo, data field encapsulation requires that data fields are defined as private.\nWhen other classes need to read a data field, we must provide a public mutator method. - See CardPrivate.java and TestCardPrivate.java.\n\nWhen we change the implementation of an object, we can still maintain compatibility with existing Java program by providing updated accessor/mutator methods that achieve the same effect as the old implementation.\n\n\n\n\n\n\n\n\nNote 7: Immutable Objects\n\n\n\nAn immutable object is an object where its properties cannot be changed after it is created.\n\n\n\nWhy we what to have immutable objects:\n\nSome computer applications are used to record a history of events which are represented by objects\nThe “historical objects” must not be changed.\n\nTo prevent the data fields of the objects being updated:\n\nPrevent the variables being updated with direct access (e.g. circle1.radius = newRadius):\n\nDefine all distance variables as private.\n\nPrevent the variables being updated with a mutator method:\n\nImmutable objects must not have any mutator methods.\n\nPrevent the variables being updated with a reference variable:\n\nImmutable objects should not have accessor methods that return a reference to an object that has public data fields.\n\n\n\n\n\n\n\n\n\nTip 1: An Example of Immutable Object:\n\n\n\n\n\nThe String class in Java will create immutable String objects: - The String class only has methods that construct a new String from an input string, and the input string is not updated.\npublic static void main(String[] args) { \n  String s1 = \"abc\"; String s2 = s1.toUpperCase();\n\n  System.out.println(s1); // \"abc\", unchanged\n  System.out.println(s2); // \"ABC\"\n}"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#passing-objects-as-parameters-to-methods",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#passing-objects-as-parameters-to-methods",
    "title": "Lecture 2 Objects and Classes",
    "section": "Passing Objects as Parameters to Methods",
    "text": "Passing Objects as Parameters to Methods\n\nMethods can have reference type parameter variables.\n\nSee TestCircle.java\n\nHowever, the following code will change the properties of the object directly:\npublic static void incrementRadius(Circle c) {\n  c.radius++; // Increment radius by 1\n}\n\npublic static void main(String[] args) {\n  Circle circle1 = new Circle(4);\n  System.out.println(circle1.getRadius()); // 4\n  incrementRadius(circle1); // radius of circle1 increases by 1\n  System.out.println(circle1.getRadius()); // 5\n}\n\nIn Java, the formal parameter c is an alias of the actual parameter circle1. So, c.circle++ will also update circle1.radius.\n\nSee CopyReference.java\n\n\nReview: Passing primitive variables to methods\n\nIn Java, the value of the argument copied (=assigned) to the parameter variable. So, x in main() and c in increment() are different variables.\nWhen increment() executes c++, it updates the parameter variable c.\nThe variable x in main() is not affected.\n\nPassing reference variables to methods\n\nThe reference type Cricle variable x contains a reference to a Circle object.\nIn Java, the value of the argument copied(=assigned) to the parameter variable. x in main() and c in increment() both reference to the same Circle object.\nWhen increment() executes c.radius++, it updates the radius variable through the referencec.\nThe variable x.radius in main() is ALSO affected because it is the same object.\n\npublic static void main(String[] arg) {\n  Circle circle1 = new Circle(4);\n  System.out.println(circle1.getRadius()); // 4.0\n  updateCircle(circle1);\n  System.out.println(circle1.getRadius()); // 4.0\n}\npublic static void updateCircle(Circle c) {\n  c = new Circle(99);\n}\n\nThe reference type Circle variable circle1 contains a reference to a Circle object.\ncircle1 in main() and c in update() both refer to the same Circle object.\nWhen update() executes c = new Circle(99), it creates another Circle object and assign its address to reference variable c.\nThe variable circle1.radius in main() is not affected.\nThrough this example, we know: we can never make x in main() refer to a different object using a method call. This is because x is passed-by-value, we cannot update x and make it refer to a different object.\nIf we really want to write a method to update the reference of x, here’s an example to do so:\n\npublic static void main(String[] arg) {\n  Circle circle1 = new Circle(4);\n  System.out.println(circle1.getRadius()); // 4.0\n  circle1 = updateCircle(circle1); // Step 2\n  System.out.println(circle1.getRadius()); // 99.0\n}\npublic static Circle updateCircle(Circle c) {\n  c = new Circle(99);\n  return c; // Step 1\n}"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#static-variables-and-constants-and-static-methods",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#static-variables-and-constants-and-static-methods",
    "title": "Lecture 2 Objects and Classes",
    "section": "Static Variables (and Constants) and Static Methods",
    "text": "Static Variables (and Constants) and Static Methods\n\nThere are 2 kinds of variables that can be defined inside a class (that is outside any method): java     public class Circle{        public double radius; // (1) an instance variable       public static int count; // (2) a \"static\" variable     }\nInstance variables and static variables of objects are different:\n\nEach object has its own copy of an instance variable.\nstatic variable belongs to the class and all objects of that class share the same copy of a static variable.\nIn other words, there is only 1 only of a static variable in a Java program.\n\npublic static void main(String[] args) {\n  CircleCount circle1 = new CircleCount(2);\n      CircleCount circle2 = new CircleCount(4);\n\n      circle1.count = 99;\n\n      System.out.println(circle1.radius); // 2.0\n      System.out.println(circle1.count); // 99\n      System.out.println(circle2.radius); // 4.0\n      System.out.println(circle2.count); // 99 \n\n      circle1.radius++; // Updates an instance variable\n      circle1.count++; // Updates a static variable\n      System.out.println(circle1.radius); // 3.0\n      System.out.println(circle1.count); // 100\n      System.out.println(circle2.radius); // 4.0\n      System.out.println(circle2.count); // 100\n}\n\ncircle1.count and circle2.count are always the same because static variables are shared\ncircle1.radius and circle2.radius are independent to each other because instance variables are not shared.\n\nApplications of static variables:\n\nThe most common application where we need to use a static variable in a class is when writing a class that can keep a count on the number of objects that has been created by a Java program.\nHow to implement?\n\nDefine a static variable named count and initialize it to zero.\nEach constructor of the class must increase the count variable by one.\n\nWhy it works?\n\nBecause when an object is created, some constructor method is invoked once, and this algorithm will keep track on the number of objects created.\n\nExample:\npublic class Circle{\n  public double radius = 1;\n  public int count = 0;\n\n  public Circle() {\n    count++;\n  }\n  public Circle(double newRadius) {\n    radius = newRadius;\n    count++;\n  }\n}\n\nThere are also two kinds of methods that can be defined inside a class: instance method and static method.\n\nInstance methods always have an implicit(=hidden) object reference parameter (this) and can access instance variables.\nstatic method do not have an implicit(=hidden) object reference parameter and cannot access instance variables.\n\nProperties of static methods:\n\nA static method belongs to a class. For this reason, static methods are also known as class methods.\nA static method can be invoked without using an object instance: Math.pow(x, n)\nstatic methods can only access static members:\n\nInvoke other static methods\nAccess static variables\nstatic methods cannot access any instance variables nor invoke instance methods.\n\n\nstatic methods are used to perform a task that is not associated with a particular object.\nInstance methods are used to perform a task using data in a specific object.\nstatic methods can be invoked in 2 different ways:\n\ninstanceVar.staticMethod(...)\nClassName.staticMethod(...)  &lt;-- Preferred\n\nSome classes may have useful constants defined in them (such as \\(\\pi\\) and \\(e\\)). Since a constant cannot change its value, we will only need one copy of it, and so a constant can always be defined as static.\nThe static block\n\nA static block is a nameless and parameterless static method in a class:\n\npublic class myClass {\n  ...  (other memebers omitted for brevity)\n\n  // A static block    \n  static\n  {\n    ... (statements)\n  }\n}\n\nUse of a static block:\n\nstatic blocks are executed before the main() method\nstatic blocks are used to initialize static variables in a class."
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html",
    "href": "notes/cs171/11-Linked-List/Linked List.html",
    "title": "Lecture 10 Linked List",
    "section": "",
    "text": "Note 1: Data Structure\n\n\n\nVariables that store information used by algorithms\n\n\n\nIdeal data structure:\n\nFast insertion (when adding a new item to data structure)\nFast deletion (when removing an item from the data structure)\nFast lookup\nMinimum memory usage\n\nUnfortunately: there is no ideal data structure.\nTwo basic data structures:\n\nArray\nLinked List\n\nArray:\n\nArray is a series of variable that\n\nare of the same data type and\nare stored in consecutive memory locations\n\nThe memory used to store an array must be allocated up front\nStrength: Fast access using an array index (because the memory address of x[i] can be computed easily).\n\nWeakness of an array: cannot increase the array size\n\nTo increase the array, we must use memory cells that follows the last element of the array.\nHowever, these memory cells may not be available (since they are used by another variable).\n\nWeakness of an array: it takes a long time to insert a value in the middle of an array.\n\nWe have to shift many elements over.\n\nThe linked list data structure:\n\nThe linked list and array are complementary to each other.\nCharacteristics of a linked list:\n\nEach list element is allocated individually (and then linked into the list)\n\n\nComparison of Arrays and Linked Lists:\n\nIt’s easy to insert/delete elements from a linked list\nIt’s hard to insert/delete elements from an array\nIt is slow to look up elements in a linked list by its index\nIt is fast to look up elements in an array by its index\n\nA linked list consists of a chain of list objects. A list object is often called a node.\nEvery node consists of two parts:\n\nOne of more data fields (contain the information stored in the linked list)\nA link (reference variable) (contains the reference (=address) of the next node/list element).\n\nThe link in the last node is null (=end of the list).\nA Java program will have a reference variable (commonly named as head or first) that contains the reference to the first node (=list element).\nConsequently, only the data stored in the first node is immediately accessible.\nAccessing the data stored in the other nodes will reply on the reference stored in the first node.\n\npublic class Node{\n    int item; // int data stored in the Node\n    Node next; // Link that reference to the next node\n}\n\nDefine a Node class for a linked list:\n\nThe class Node contains a reference variable next that references to a Node (same class) object.\nThe next variable is used to create a chain of Nodes\nWe can define other data field depending on what we want to store in a Node.\n\n\n\n\n\n\n\n\n\nArray\nLinked List\n\n\n\n\nArray elements are stored contiguously in memory\nList elements (=nodes) do not need to be stored contiguously in memory\n\n\nAll array elements are allocated at once\nNodes can be allocated piece meal when needed\n\n\nOnce allocated, the number of elements in the array is fixed\nWe can increase the number of elements in a list easily by increasing the length of the chain\n\n\nOnly store data fields, do not need to store non-data fields\nRequires the use of a linking field (next) to create a chain\n\n\nAccessing the k-th element in an array is fast\nNeed to traverse the chain to reach the k-th element - slow\n\n\nInserting a value in the middle of an array is difficult (need to shift elements over)\nInserting a node in the middle of a linked list is easy"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#introduction",
    "href": "notes/cs171/11-Linked-List/Linked List.html#introduction",
    "title": "Lecture 10 Linked List",
    "section": "",
    "text": "Note 1: Data Structure\n\n\n\nVariables that store information used by algorithms\n\n\n\nIdeal data structure:\n\nFast insertion (when adding a new item to data structure)\nFast deletion (when removing an item from the data structure)\nFast lookup\nMinimum memory usage\n\nUnfortunately: there is no ideal data structure.\nTwo basic data structures:\n\nArray\nLinked List\n\nArray:\n\nArray is a series of variable that\n\nare of the same data type and\nare stored in consecutive memory locations\n\nThe memory used to store an array must be allocated up front\nStrength: Fast access using an array index (because the memory address of x[i] can be computed easily).\n\nWeakness of an array: cannot increase the array size\n\nTo increase the array, we must use memory cells that follows the last element of the array.\nHowever, these memory cells may not be available (since they are used by another variable).\n\nWeakness of an array: it takes a long time to insert a value in the middle of an array.\n\nWe have to shift many elements over.\n\nThe linked list data structure:\n\nThe linked list and array are complementary to each other.\nCharacteristics of a linked list:\n\nEach list element is allocated individually (and then linked into the list)\n\n\nComparison of Arrays and Linked Lists:\n\nIt’s easy to insert/delete elements from a linked list\nIt’s hard to insert/delete elements from an array\nIt is slow to look up elements in a linked list by its index\nIt is fast to look up elements in an array by its index\n\nA linked list consists of a chain of list objects. A list object is often called a node.\nEvery node consists of two parts:\n\nOne of more data fields (contain the information stored in the linked list)\nA link (reference variable) (contains the reference (=address) of the next node/list element).\n\nThe link in the last node is null (=end of the list).\nA Java program will have a reference variable (commonly named as head or first) that contains the reference to the first node (=list element).\nConsequently, only the data stored in the first node is immediately accessible.\nAccessing the data stored in the other nodes will reply on the reference stored in the first node.\n\npublic class Node{\n    int item; // int data stored in the Node\n    Node next; // Link that reference to the next node\n}\n\nDefine a Node class for a linked list:\n\nThe class Node contains a reference variable next that references to a Node (same class) object.\nThe next variable is used to create a chain of Nodes\nWe can define other data field depending on what we want to store in a Node.\n\n\n\n\n\n\n\n\n\nArray\nLinked List\n\n\n\n\nArray elements are stored contiguously in memory\nList elements (=nodes) do not need to be stored contiguously in memory\n\n\nAll array elements are allocated at once\nNodes can be allocated piece meal when needed\n\n\nOnce allocated, the number of elements in the array is fixed\nWe can increase the number of elements in a list easily by increasing the length of the chain\n\n\nOnly store data fields, do not need to store non-data fields\nRequires the use of a linking field (next) to create a chain\n\n\nAccessing the k-th element in an array is fast\nNeed to traverse the chain to reach the k-th element - slow\n\n\nInserting a value in the middle of an array is difficult (need to shift elements over)\nInserting a node in the middle of a linked list is easy"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#implementing-a-simple-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#implementing-a-simple-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Implementing a Simple Linked List",
    "text": "Implementing a Simple Linked List\n\nOperations on a Linked List\n\nThe linked list is a data structure used to store information.\nTo be useful as a data structure, the linked list must support the following operaqtions:\n\nCreate an empty linked list\nInsert a data item into the linked list\n\nInsert it at the beginning of the linked list\nInsert it at the end of the linked list\n\nDelete a data item from the linked list\n\nInsert the element at the beginning of the linked list\nInsert the element at the end of the linked list\n\nSearching for some data item in the linked list\n\nSearch by its index\nSearch by its key value\n\n\n\nConstructing a linked list using explicit helper reference variables\n\npublic class Demo {\n    public static Node first; // Define the first variable\n    \n    public static void main(String[] args) {\n        Node help1 = new Node();\n        Node help2 = new Node();\n        Node help3 = new Node();\n\n        help1.item = \"to\";\n        help2.item = \"be\";\n        help3.item = \"or\";\n\n        // Create the chain\n        help1.next = help2;\n        help2.next = help3;\n        help3.next = null;\n\n        first = help1;\n    }\n}"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#standard-list-traversal-algorithm",
    "href": "notes/cs171/11-Linked-List/Linked List.html#standard-list-traversal-algorithm",
    "title": "Lecture 10 Linked List",
    "section": "Standard List Traversal Algorithm",
    "text": "Standard List Traversal Algorithm\n// The standard list raversal algorithm\nNode p;\np = first; // p now points to the first node\n\nwhile (p != null) {\n    // process data p.item in node p\n    p = p.next; // advances p to next node\n}\n\n\n\n\n\n\nTip 1: Use the list traversal algorithm to print out all items in a list\n\n\n\n\n\nNode current;\ncurrent = first; // initialize current to the first node\nwhile (p != null) {\n    System.out.println(current.item);\n    current = current.next;\n}\n\n\n\n\nEnhancements of the list traversal algorithm: find a node that contains X.\n\nNode current = first;\nwhile (current != null && !current.item.equals(\"X\")) {\n    current = current.next;\n}\n\nUse the list traversal algorithm to find a list element that contains a certain key\n\n/**\n * This method returns a list element that contains a certain value\n * @param f the linked list to be searched\n * @param s the value of searching\n * @return the node containing s\n */\npublic static Node findNode(Node f, String s) {\n    Node current = f;\n    while (current != null) {\n        if (current.item.equals(s)) { // found! \n            return current;\n        }\n        current  = current.next;\n    }\n    return null; // not found\n} \n\nList traversal using a for-loop: print out item in the linked list using a for-loop:\n\nfor (Node p = first; p != null; p = p.next) {\n    System.out.println(p.item);\n}"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#implementing-the-standard-operations-on-a-simple-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#implementing-the-standard-operations-on-a-simple-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Implementing the Standard Operations on a Simple Linked List",
    "text": "Implementing the Standard Operations on a Simple Linked List\n\nOperations on a linked list:\n\nTest if a list is empty\nGet the item at the start\nGet the item at the end\nInsert an item at the start\nInsert an item at the end\nDelete the item at the start\nDelete item at the end\nGet the item at position k in the linked list\nRemove the first item that contains the value key from the linked list\n\npublic interface SimpleList&lt;T&gt; { // A list that store objects of type T\n  public boolean isEmpty(); // check if the list is empty\n\n  public T getFirst(); // get the first item in the list\n  public T getLast(); // get the last item in the list\n\n  public void addFirst(T item); // add an item to the beginning of the list\n  public T removeFirst(); // remove the first item from the list\n\n  public voild addLast(T item); // add an item to the end of the list\n  public T removeLast(); // remove the last item from the list\n\n  public T get(int pos); // get the item at position pos in the list\n  public void remove(T key); // remove the first item that contains the value key from the list\n}\n\nimport java.util.NoSuchElementException;\n\npublic class GenericLinkedList&lt;T&gt; implements SimpleList&lt;T&gt; {\n    // Start of the inner class Node\n    public class Node&lt;T&gt; {\n        // Node instance variables\n        private T item; // the data stored in the node\n        private Node&lt;T&gt; next; // the link to the next node\n\n        // Constructor for Node\n        public Node(T item, Node&lt;T&gt; next) {\n            this.item = item;\n            this.next = next;\n        }\n\n        public String toString() {\n            return \"\" + this.item;\n        }\n    } // End of the inner class Node\n\n    // The list starts at first\n    private Node&lt;T&gt; first;\n\n    // Contructs an empty list\n    public GenericLinkedList() {\n        first = null;\n    }\n\n    // check if the list is empty\n    public boolean isEmpty(){ \n        return first == null;\n    }\n\n    // get the first item in the list\n    public T getFirst() {\n        // Edge case: list is empty\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return first.item; // retrieves item in first node\n    }\n    // get the last item in the list\n    public T getLast() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        // (1) Find the last node\n        Node&lt;T&gt; current = first;\n        while (current.next != null) {\n            current = current.next;\n        }\n        // (2) Return item stored in this node\n        return current.item;\n    }\n\n    // add an item to the beginning of the list\n    public void addFirst(T item) {\n        Node&lt;T&gt; = newNode = new Node&lt;&gt;(item, first);\n        first = newNode;\n    }\n    // remove the first item from the list\n    public T removeFirst() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        T toReturn = first.tiem // first = null -&gt; crash\n        first = first.next;\n        return toReturn;\n    } \n\n    // add an item to the end of the list\n    public voild addLast(T item) {\n        if (isEmpty()) { // edge case\n            first = new Node&lt;&gt;(item, null);\n            // equivalent to: addFirst(item)\n        } else {\n            // (1) Find the last element in the linked list\n            Node&lt;T&gt; current = first; // if first = null -&gt; crash\n            while (current.next != null) { // Find the last element -&gt; list traversal\n                current = current.next;\n        }\n        // (2) Mkae a new Node with data to linke to the last element \n        current.next = new Node&lt;&gt;(item, null);\n        }\n    }\n    // remove the last item from the list\n    public T removeLast() {\n        // Edge case 1: list is empty\n        if (isEmpty()) { // empty list cannot remove anything\n            throw new NoSuchElementException();\n        }\n        // Edge case 2: list only contain one element\n        if (first.next == null) {\n            Node&lt;T&gt; ret = firtst; // save for return\n            first = null; // unlink by updating first\n            return ret.item;\n        }\n        //General Case: list not empty and have at least 2 elements\n        // to remove last, we need information of the second last element\n        Node&lt;T&gt; previous = first;\n        Node&lt;T&gt; current = first;\n\n        while (current.next != null) { // find the last list element\n            previous = current; // keep track of the previous node\n            current = current.next;\n        }\n        // previous points to the predecessor node of the last node\n        // current points to the last node\n        // Unlink the last node\n        previous.next = null;\n        // return item in the last node\n        return current.item;\n    } \n\n    // get the item at position pos in the list\n    public T get(int pos) {\n        // Edge case\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        // General case\n        int i = 0;\n        Node&lt;T&gt; current = first;\n        while (current != null) {\n            if (i == pos) {\n                break;\n            }\n            i++;\n            current = current.next;\n        }\n        if (current == null) {\n            throw new IndexOutOfBoundsException();\n        \n        }\n        return current.item;\n    }\n    // remove the first item that contains the value key from the list\n    public void remove(T key) {\n       // Edge case 1: list is empty\n       if (first == null) { \n           throw new NoSuchElementException();\n       } else if (first.item.equals(key)) {\n           // Edge case 2: the first item is the key\n           first = first.next\n       } else {\n           // General case\n           // (1) Find the predecessor node of the node containing item == key\n           Node&lt;T&gt; = current = first; // Initialize\n           Node&lt;T&gt; = previous = first;\n           while (current != null && !current.item.equals(key)) {\n               previous = current;\n               current = current.next;\n           }\n           if (current == null) {\n               // key not found\n               throw new NoSuchElementException ();\n           }\n           // (2) Unlink the targeted node from its predecessor node \n           previous. next = current.next;\n       }\n    }\n}\n\nIt is important to consider edge cases when defining methods.\n\nOften, the edge cases are:\n\nThe empty list: first == null\nA list contains onlly 1 element: first == null\n\n\nGarbage: Note that we origianl first node is not referenced to by any permanent variables after the operation removeFirst()\n\nSuch objects are known as garbage\nObjects that become garbage are inaccessible and unusable in the program"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#other-types-of-simple-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#other-types-of-simple-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Other types of Simple Linked List",
    "text": "Other types of Simple Linked List\n\nSimple Linked List\n\nThe simple (or singly-cahined) linked list is chained linearly and without a loop\nA variant of the simple linked list is double-ended list. It uses a last reference to help find the last element quickly.\nThe simple circular linked list is chained linearly and contains a loop.\n\nDoubly Linked List\n\nThe doubly linked list is a chained linearly using forward and backward links without a loop.\nThe doubly linked circular list is chained using forward and backward links and contains two loops"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#using-a-linked-list-in-a-for-each-loop---implementing-the-iterable-interface-and-the-iterator-interface",
    "href": "notes/cs171/11-Linked-List/Linked List.html#using-a-linked-list-in-a-for-each-loop---implementing-the-iterable-interface-and-the-iterator-interface",
    "title": "Lecture 10 Linked List",
    "section": "Using a Linked List in a for-each Loop - Implementing the Iterable Interface and the Iterator Interface",
    "text": "Using a Linked List in a for-each Loop - Implementing the Iterable Interface and the Iterator Interface\n\nJava has a for-each loop that iterates over collection objects:\n\nfor (dataType x : Collection) {\n    // operations on x\n}\n\nFor example, an ArrayList is an iterable collection\n\nArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;();\na.add(1); a.add(2); a.add(3);\n\nfor (Integer i : a) {\n    System.out.println(i);\n}\n\nWe can use an ArrayList in the for-each loop because the ArrayList is Iterable. Our previous implementation of the GenericLinkedList class is not iterable, so we cannot use it in the for-each loop.\nNow, we make some changes to the GenericLinkedList class so that it is iterable:\n\npublic class GenericLinkedList&lt;T&gt; implements SimpleList&lt;T&gt;, Iterable&lt;T&gt; {\n    // Private inner class Node\n    private class Node&lt;T&gt; {\n        private T item;\n        private Node&lt;T&gt; next;\n\n        // ...\n    }\n\n    // Private inner class MyLinkedListIterator\n    private class MyLinkedListIterator&lt;T&gt; implements Interator&lt;T&gt; {\n        private Node&lt;T&gt; current; // current position in the iteration\n\n        public MyLinkedListInterator(Node&lt;T&gt; f) { // contructor\n            current = f; // initialize\n        }\n\n        public boolean hasNext() {\n            // returns true if there are more nodes\n            return current != null;\n        }\n\n        public T next() {\n            // return the next element in the iteration\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            T res = current.item; // get the current item\n            current = current.next; // advance to the next node\n            return res;\n        }\n    }\n    private Node&lt;T&gt; first;\n    public GenericLinkedList() {\n        first = null;\n    }\n    // ... Other methods\n    public Iterator&lt;T&gt; iterator() { // implements the Iterable interface\n        return new LinkedListIterator&lt;T&gt;(first);\n    }\n}"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#use-linked-list-to-implement-a-stack",
    "href": "notes/cs171/11-Linked-List/Linked List.html#use-linked-list-to-implement-a-stack",
    "title": "Lecture 10 Linked List",
    "section": "Use Linked List to Implement a Stack",
    "text": "Use Linked List to Implement a Stack\npublic class ListStack&lt;T&gt; implements MyStack&lt;T&gt; {\n    // private inner class Node\n    prviate class Node&lt;T&gt; {\n        private T item;\n        private Node&lt;T&gt; next;\n\n        public Node(T item, Node&lt;T&gt; next) {\n            this.item = item;\n            this.next = next;\n        }\n\n        public String toString() {\n            return \"\" + this.item;\n        }\n    } // End of the private inner class Node\n\n    private Node&lt;T&gt; frist;\n\n    public ListStack() { // constructor\n        first = null; //empty list = empty stack\n    }\n\n    // returns true is stack is empty\n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    // returns true if stack is full\n    public boolean isFull() {\n        return false; // linked list is not fixed size\n    }\n\n    // push(item) -&gt; insert at the front of the list\n    public void push(T item) {\n        Node&lt;T&gt; newNode = new Node&lt;T&gt;(item, first);\n        first = newNode;\n    }\n\n    // pop() -&gt; remove the first item and return it\n    public T pop() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        T toReturn = first.item;\n        first = first.next;\n        return toReturn;\n    }\n\n    // peek() -&gt; return the first item\n    public T peek() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return first.item;\n    }\n}\n\nProperties of the stack implementation using a linked list\n\nThe push() and pop() does not have any loops!\n\nWe say that the push() and pop() runs in constant time\n\nWe can also implement a stack using push(item)=addLast(item) and pop()=removeLast().\n\nHowever, this is not preferred because addLast() and removeLast() requires the use of the list traversal algorithm and will run slower."
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#implementing-queue-using-a-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#implementing-queue-using-a-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Implementing Queue Using a Linked List",
    "text": "Implementing Queue Using a Linked List\npublic class ListQueue&lt;T&gt; implements MyQueue&lt;T&gt; {\n    // private inner class Node\n    private class Node&lt;T&gt; {\n        private T item;\n        private Node&lt;T&gt; next;\n\n        public Node(T item, Node&lt;T&gt; next) {\n            this.item = item;\n            this.next = next;\n        }\n\n        public String toString() {\n            return \"\" + this.item;\n        }\n    } // End of private inner class\n\n    private Node&lt;T&gt; first;\n\n    public ListQueue() { // constructor\n        first = null; // empty list = empty queue\n    }\n\n    // returns true if queue is empty\n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    // returns true if queue is full\n    public boolean isFull() {\n        return false; // linked list is not fixed size\n    }\n\n    // enqueue(item) -&gt; insert at the end of the list\n    public void enqueue(T item) {\n        if (isEmpty()) {\n            first = new Node&lt;T&gt;(item, null);\n        } else {\n            Node&lt;T&gt; current = first;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = new Node&lt;T&gt;(item, null);\n        }\n    }\n\n    // dequeue() -&gt; remove the first item and return it\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        T toReturn = first.item;\n        first = first.next;\n        return toReturn;\n    }\n\n    // peek() -&gt; return the first item\n    public T peek() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return first.item;\n    }\n}\n\nPostscript:\n\nWe can also implement a queue using:\n\nenqueue(item) = addFirst(item)\ndequeue() = removeLast()"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#javas-linkedliste-class",
    "href": "notes/cs171/11-Linked-List/Linked List.html#javas-linkedliste-class",
    "title": "Lecture 10 Linked List",
    "section": "Java’s LinkedList<E> Class",
    "text": "Java’s LinkedList&lt;E&gt; Class\n\nJava’s LinkedList&lt;E&gt; class implemented as a doubly-linked list\nSample methods:\n\nsize() // returns the number of elements in this list\n\naddFirst(E e);\naddLast(E e);\nadd(int index, E element)\n\nremoveFirst();\nremoveLasT();\nremove(int index)\n\ngetFirst();\ngetLast();\nget(int index)"
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html",
    "title": "Lecture 9 Queue Data Structure",
    "section": "",
    "text": "Recall: there are two commonly used data structures in computer science:\n\nStack (LIFO)\nQueue (FIFO)\n\n\n\n\n\n\n\n\nNote 1: Queue data structure\n\n\n\nA queue is a data structure that organizes the stored data in a First In First Out (FIFO) manner.\n\n\n\nTo achieve the FIFO behavior, the queue only provide the following two methods to access the data stored in a queue:\n\nenqueue(x): add x to the tail/back of the queue\ndequeue(): remove the item at the head/front of the queue and return it.\n\nSome computer algorithms/processes with a natural LIFO behavior:\n\nScheduling for fairness:\n\nFIFO is a service ordering that is fair.\nScheduling algorithms that serve requests from different clients often implement a FIFO service policy using a queue.\n\nThe Breath First Search (BFS) algorithm in graph applications:\n\nThe BFS algorithm will probe nodes that are nearest to the source nodes first.\nTo implement the “search the nearest nodes first” behavior, the BFS algorithm use a queue to store nodes to visit next."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#introduction-to-queue",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#introduction-to-queue",
    "title": "Lecture 9 Queue Data Structure",
    "section": "",
    "text": "Recall: there are two commonly used data structures in computer science:\n\nStack (LIFO)\nQueue (FIFO)\n\n\n\n\n\n\n\n\nNote 1: Queue data structure\n\n\n\nA queue is a data structure that organizes the stored data in a First In First Out (FIFO) manner.\n\n\n\nTo achieve the FIFO behavior, the queue only provide the following two methods to access the data stored in a queue:\n\nenqueue(x): add x to the tail/back of the queue\ndequeue(): remove the item at the head/front of the queue and return it.\n\nSome computer algorithms/processes with a natural LIFO behavior:\n\nScheduling for fairness:\n\nFIFO is a service ordering that is fair.\nScheduling algorithms that serve requests from different clients often implement a FIFO service policy using a queue.\n\nThe Breath First Search (BFS) algorithm in graph applications:\n\nThe BFS algorithm will probe nodes that are nearest to the source nodes first.\nTo implement the “search the nearest nodes first” behavior, the BFS algorithm use a queue to store nodes to visit next."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#the-queue-interface",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#the-queue-interface",
    "title": "Lecture 9 Queue Data Structure",
    "section": "The Queue Interface",
    "text": "The Queue Interface\npublic interface MyQueueInterface&lt;E&gt; {\n    boolean isEmpty(); // returns true if the queue is empty\n    boolean isFull(); // returns true if the queue is full\n\n    void enqueue(E e); // insert the element e at the back of the queue\n    \n    E dequeue(); // remove the element at the front of the queue and return it\n\n    E peek(); // return the element at the front without removing it. \n}"
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#implementing-a-queue-using-a-circular-array",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#implementing-a-queue-using-a-circular-array",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Implementing a Queue using a (Circular) Array",
    "text": "Implementing a Queue using a (Circular) Array\n\nWe can implement a queue with a fixed size array and 2 indices head and tail, where\n\nhead = location of the front (first position) of the queue\ntail = location of the open spot at the tail (last position) of the queue\n\nThe enqueue(x) method will append the element x at the tail of the queue.\nHowever, elements dequeued from the front of the array will cause some spaces unused. To solve it, we need to copy the elements to the front of the array, which requires many copy operations.\nThen, to avoid frequently copying arrays to save spaces, we will use a circular array instead.\n\n\n\n\n\n\n\nNote 2: Circular Buffer\n\n\n\nAlso known as circular array or ring buffer, is a data structure that uses an array as if it were connected end-to-end.\n\n\n\nThe circular buffer data structure consists of an array with 2 pointers or indices:\n\nread pointer = the index of the read position in the array\nwrite pointer = the index of the write position in the array\n\nWhen the write (or read) pointer reaches the end of the array/buffer, the write (or read) will wrap around and reset to 0. To achieve the wrap around effect, the read (or write) pointer variables is updated using modulo arithmetic.\n\n// Normal increment operation:\nwrite = wrtie + 1;\nread = read + 1;\n\n// Increatment operation with modulo arithmetic:\nwrite = (write + 1) % buf.length;\n\n// Suppose writhe = 15 and buf.length = 16, then\n// write = (write+1)%buf.length = (15+1)%16 = 16%16 = 0\n\nThe write() operation on a circular buffer will store the data at the write pointer and advance it. The basic implementation of the write() operation (without checking if buffer is full):\n\nvoid write(T e) {\n    buf[write] = e;\n    write = (write + 1) % buf.length;\n}\n\nThe read() operation will return the data at the read pointer and advance it. The basic implementation of the read() operation (without checking if buffer is empty):\n\nT read() {\n    T retVal = but[read];\n    read = (read + 1) % buf.length;\n    return retVal;\n}\n\nHow to tell if a circular buffer if empty or full:\n\nThe circular buffer is not empty when read != write\nThe circular buffer is empty when read == write\nThe circular buffer is not full when read != write\nThe circular buffer is full when read == write. –&gt; This causes problem: this also means empty.\nTo avoid ambiguity, we define the circular buffer to be full when there is 1 empty slot left.\n\nThe implementation of the queue data structure using a circular buffer:\n\npublic class IntegerQueue implements MyQueueInterface&lt;Integer&gt; {\n    private Integer[] buf; // Array of the circular buffer\n    private int read; // read pointer (= head index of queue)\n    private int write; // write pointer (= tail index of queue)\n\n    // Constructor\n    public IntegerQueue(int N) {\n        // Variable of the circular buffer\n        buf = new Integer[N]; // Create new array\n        read = 0; // initialize read pointer\n        write = 0; // initialize write pointer\n    }\n\n    /**\n     * The queue is empty when read pointer == write pointer\n     * @return true if the queue is empty\n     */ \n    public boolean isEmpty() {\n        return read == write;\n    }\n\n    /**\n     * The queue is full when there is one open spot left\n     * @return true if the queue is full\n     */\n    public boolean isFull() {\n        // buffer has 1 open spot\n        // &lt;==&gt; write 1 item into the buffer and it's full\n        return (write + 1) % buf.length == read;\n    } \n\n    public void enqueue(Integer e) {\n        if (isFull()) {\n            System.out.println(\"Full\"); // or throw exception\n            return;\n        }\n        buf[write] = e;\n        write = (write + 1) % buf.length;\n    }\n\n    public Integer dequeue() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\"); // or throw exception\n            return null;\n        }\n        Integer retVal = buf[read];\n        read = (read + 1) % buf.length;\n        return retVal;\n    }\n\n    public Integer peek() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\"); // or throw exception\n            return null;\n        }\n        return buf[read];\n    }\n}"
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---double-ended-de-queue",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---double-ended-de-queue",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Other Kinds of Queues - Double Ended (DE) Queue",
    "text": "Other Kinds of Queues - Double Ended (DE) Queue\n\n\n\n\n\n\nNote 3: Double Ended Queue\n\n\n\nA double ended queue is a data structure where we can insert or delete elements from either end\n\nThe operations on a Deque are:\n\naddFirst(x): insert x at the front of the Deque\naddLast(x): insert x at the tail of the Deque\nremoveFirst(x): remove the element at the front of the Deque and return it\nremoveLast(x): remove the element at the tail of the Deque and return it -\n\nA Double Ended Queue can work/operate like a stack. It can also work/operate like a queue."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---priority-queue",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---priority-queue",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Other Kinds of Queues - Priority Queue",
    "text": "Other Kinds of Queues - Priority Queue\n\n\n\n\n\n\nNote 4: Priority Queue\n\n\n\nA priority queue is a data structure where\n\nThe stored data items can be ranked by some field rank in the data\nThe dequeue() operation will always remove the item in the priority queue that has the highest value in the rank field.\n\n\n\n\nThe priority queue is important in time cricical applications:\n\nSelect the next job to run (pick the most urgent one)\nSelect the next patient to treat, etc.\n\nA native implementation of the priority queue:\n\nUse a fixed size array\nenqueue(x) must make sure the array is sorted all the time (from large to small)\ndequeue(x) removes the first element in the array\n\nAnother naive implementation of the priority queue:\n\nUse a fixed size array\nenqueue(x) insert the element at the end\ndequeue(x) search the array for the largest element and remove it\n\nAn efficient implementation of the priority queue:\n\nThe heat data structure\nA heap is a complete binary tree data structure where the largest value is always stored in the root of the tree."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#use-a-queue-in-javas-library",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#use-a-queue-in-javas-library",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Use a Queue in Java’s Library",
    "text": "Use a Queue in Java’s Library\n\nUnlike the Stack (which is a class), the Queue is an interface in Java’s library.\nThe Queue interface is implemented by several classes, including\n\nArrayDeque\nPriorityQueue\n\nSome basic methods in the Queue interface:\n\nadd(E e): Inserts the specified element into this queue\nremove(): retrieves and removes the head of this queue\n\nExample:\n\npublic static void main(String[] args) {\n    Queue&lt;Integer&gt; s = new ArrayDeque&lt;&gt;();\n\n    s.add(1);\n    System.out.println(s); // [1]\n    s.add(2);\n    System.out.println(s); // [1, 2]\n\n    System.out.println(s.remove()); // 1\n    System.out.println(s); // [2]\n}"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriente-d-thinking",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriente-d-thinking",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Object-Oriente-d Thinking",
    "text": "Object-Oriente-d Thinking\n\nObject-Oriente-d Thinking\n\nIn order to maximize the inheritance mechanism to re-use existing software, we need to adopt the Object-Oriente-d Design methodology when developing the classes.\nThe Object-Oriente-d Design methodology organizes object class in a hierarchy according to common properties and actions\nThe Object-Oriente-d methodology can minimize the re-use of variables and methods.\n\nHow to maximize the sharing of properties and/or actions among classes\n\nWe use a class to model objects of the same type\nDifferent classes can have common properties and/or behaviors\nTo maximize sharing of common properties/behaviors, we generalize different classes into a large (super) class.\n\nThe is-a generalization method will give us the maximum sharing of properties and actions\n\n\nThe Object-Oriente-d Design methodology uses the is-a generalization technique to achieve maximal sharing of properties and actions between classes.\nHow to design the class hierarchy using the is-a generalization technique\n\nFirst, determine all the program classes that we will need to solve the problem. Determine the properties and actions that are needed in each class.\nThen, generalize similar program classes using the is-a generalization. Use the properties and actions in each class to find the more general classes.\nIf possible, generalize further. Use the final hierarchy to determine the properties and actions of each class. &gt; Superclass: the more general class in the is-a relationship (aka, parent class)\nA super class has a number of properties and actions. &gt; Subclass: the more specific class in the is-a relationship (aka, child class)\nEvery object of the subclass will have all the properties and actions in the superclass.\nIn addition, the subclass object can have other properties and actions not found in the superclass.\n\nSee TestGeometricObject.java\n\n\nThe OOP design allows us to avoid duplications of codes when solving a problem. - See TestOldWay.java\n\nWe define a superclass that contains the common (shared) properties and actions in all classes\n\nSome methods in the superclass may not have a useful method body - it’s OK. This is very useful for the polymorphism mechanism.\n\nWe create subclasses that extend the superclass.\n\nFor private instance variables, we must use its accessor/mutator methods to use the variables.\nFor public instance variables, we can access them directly.\n\nWe can override some methods in the subclass.\n\nRelationship between a subclass and its superclass\n\nA subclass inherits all variables and (normal) methods from its superclass.\nA subclass do not inherit any constructor method from its superclass.\n\nA constructor in the subclass must invoke a constructor in the superclass\nA subclass object always contains a superclass object.\nObjects are initialized using its constructor\n\nRule: a constructor in the subclass must invoke some constructor in its superclass as its first statement.\n\nThe keyword super(...) is used to invoke a constructor in its superclass.\n\nRule: if a constructor in the subclass does not invoke any constructor in its superclass, then, the Java compiler will automatically insert the call super() as the first statement. That is, when the first statement in a constructor is not super(...), the Java compiler will call the default constructor.\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    // Compile error -- why?\n  }\n}\n\npublic class SomeClass {\n  public int x;\n  public SomeClass(int a) {\n    x = a;\n  }\n}\n\nThe compile error is because the constructor NewClass() does not contain any super(...) calls, so Java compile will insert super(...):\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    super();\n  }\n}\n\nHowever, there is not matching constructor (SomeClass()) defined in the supercalss, which causes the error.\n\nConsequences of the constructor invocation rule in Java:\n\nConstructor invocation rule in Java:\n\nIf a class B inherits from class A, then every constructor in class B must invoke some constructor in class A.\n\nConsequence:\n\nIf another class C inherits from the class B, then every constructor in class C must invoke some constructor in class B and in class A.\nThis phenomenon is called constructor chaining.\n\n\nSummary:\n\nA subclass inherits all normal members (including private members) from its superclass\nMethods in the subclass cannot access the private inherited members directly.\nA subclass object contains (all members in) a supercalss object.\nA subclass do not inherit any constructors from its superclass.\nBecause a subclass object contains (All members in) a superclass object, every constructor in the subclass must invoke a constructor in the superclass.\n\nSometimes, we must use the overridden method inside the super class (i.e., use super.methodName())\nSee 05-bank-account:\n\nBankAccount.java\nSavingAccount.java\nTestSavingAccount.java"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#the-protected-modifier-and-the-final-modifier",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#the-protected-modifier-and-the-final-modifier",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "The protected Modifier and the final Modifier",
    "text": "The protected Modifier and the final Modifier\n\nThe accessibility modifiers indicates the degree of trust (closeness) of program code written by different people.\n\nHighest level of trust: Code inside a class\n2nd highest level of trust: code inside a package\nLowest level of trust: code inside a different package.\nThe protected modifier will allow subclasses inside a different package to access data fields or methods in the superclass.\nSyntax to define a member with protected accessibility:\n\n  protected memberDefinition;\n\nWhere we can access with protected accessibility:\n\nfrom inside a method in the same class (closest association)\nfrom inside a method in the same package (2nd closest association)\nfrom inside a method in a subclass defined outside the package\nbut not from inside a method in an unrelated class defined outside the package\n\n\n\n\n\n\n\n\n\n\n\n\nModifier on Members\nfrom the same class\nfrom the same package\nfrom subclass in different package\nfrom a different package\n\n\n\n\npublic\nOK\nOK\nOK\nOK\n\n\nprotectd\nOK\nOK\nOK\nNo\n\n\ndefault\nOK\nOK\nNo\nNo\n\n\nprivate\nOK\nNo\nNo\nNo\n\n\n\n\nSee TestNewCircle.java and TestNewCircle.java\nA class with the final qualifier cannot be extended (i.e., used as a superclass)\n\n// This class cannot be extended\npublic final class myClass {\n  // data fieds, constrcutors, and methods omitted.\n}\n\nA method with the final qualifier cannot be overridden in a subclass\n\npublic class myClass {\n  // This method cannot be overridden\n  public final void method1() {\n    // Do something,\n  }\n}\n\nSee FinalCircle.java and FinalGeometricObject.java"
  },
  {
    "objectID": "photo.html",
    "href": "photo.html",
    "title": "Photograph",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays---for-a-given-search-value-key-find-the-index-of-the-first-array-element-that-contains-the-search-value-key.---return--1-when-the-key-is-not-found-in-the-array.",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays---for-a-given-search-value-key-find-the-index-of-the-first-array-element-that-contains-the-search-value-key.---return--1-when-the-key-is-not-found-in-the-array.",
    "title": "Lecture 7 Array Data Structure",
    "section": "The Search Problem for Arrays: > - For a given search value key, find the index of the first array element that contains the search value key. > - Return -1 when the key is not found in the array.",
    "text": "The Search Problem for Arrays: &gt; - For a given search value key, find the index of the first array element that contains the search value key. &gt; - Return -1 when the key is not found in the array."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays",
    "title": "Lecture 7 Array Data Structure",
    "section": "The Search Problem for Arrays:",
    "text": "The Search Problem for Arrays:\nFor a given search value key, find the index of the first array element that contains the search value key. - Return -1 when the key is not found in the array."
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html",
    "title": "Lecture 11 Complexity Analysis",
    "section": "",
    "text": "We want to know how can we measure the “goodness” of a program/algorithm?\nWe have some ways to measure:\n\nRunning time (the shorter, the better)\nMemory utilization (the less the better)\nAmount of code (?)\nEtc.\n\nThe most commonly used performance measure is the running time.\nTo measure running time, we can use a stop watch (i.e., use real time as measure). However, there are some problems associated:\n\nThe same program can have different running time on different computers\nDifferent inputs can result in different running time - hard to find their relationship\n\nSo, we need to rely on an more objective measure: count the number of instructions executed by a program for a given input size.\nHowever, this measure is not practical. In practice, we will count the number of “primitive operations” executed by a program for a given input size.\nAlgorithms make repeated steps towards the solution. The primitive operation is a step in the algorithm.\n\nfor (int i = 0; i &lt; N; i++) {\n    S1;\n    S2;\n    ...\n    SN\n}\nThe primitive operation of this algorithm consists of the statementS1; S2; ...; SN.\n\nPrinciples of Algorithm Analysis\n\nAlgorithm analysis consists of\n\nDetermine frequency (=count) of primitive operations\nCharacterize the frequency as a function of the input size\n\nThe algorithm analysis must\n\nTake into account all possible inputs (good ones and bad ones)\nBe independent of hardware/software environment\nBe independent from the programming language\nGive a good estimate that is proportional to the actual running time of the algorihtm\n\n\nGood inputs, Bad inputs, and Average cases\n\nInput data can affect the running time of algorithms\nThe best case are not studied because we cannot count on luck.\nThe worst case gives us an upper bound\n\nThe worst case analysis provides an upper bound on the running time of an algorithm.\nThe analysis is easier to do compare to average case analysis.\n\nThe average case is what we would expect.\n\nTake the average running time over all possible inputs of the same size\nThe analysis depends on input distribution\nThe analysis is harder to do because it uses probability techniques.\n\n\nTechniques used in Algorithm Analysis\n\nThere are two main techniques used in Algorithm Analysis:\n\nLoop analysis\nRecurrence relations\n\nA program spends the most amount of time in loops. One of the technique used in algorithm analysis is loop analysis.\nSome algorithms are recursive. The running time complexity of recursive algorithms are often expressions as recurrence relations. Another technique is solving recurrence relations\n\n\n\n\n\n\n\n\nTip 1: Recurrence Relation\n\n\n\n\n\n\\[ C(n)=2\\times C(n/2)+1 \\]\n\n\n\n\n\n\nConsider the following program fragment, how many times is the loop body executed?\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 2: Solution 1\n\n\n\n\n\n\\[n\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i = i + 2) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 3: Solution 2\n\n\n\n\n\n\\[\\dfrac{n}{2}\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; ++) { \n        sum += array[i] * array[j]; \n    }\n}\n\n\n\n\n\n\nTip 4: Solution 3\n\n\n\n\n\n\\[n\\times n=n^2\\]\n\n\n\n\nThe running time in terms of the input size (\\(n\\)) can be a general mathematical function. However, we are interested in the order of the growth function (but not the exact function).\n\n\n\n\n\n\n\nNote 1: Approximate Definition of Order, Similar/\\(\\sim\\)\n\n\n\nGiven 2 functions \\(f(x)\\) and \\(g(x)\\), we say \\(f(x)\\sim g(x)\\) if \\(\\dfrac{f(x)}{g(x)}=1\\) when \\(n\\to\\infty\\).\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn running time analysis, we can ignore the less significant terms.\n\n\n\n\n\n\n\n\nNote 2: Precise Definition of Order, \\(\\mathcal{O}\\) notation\n\n\n\nGiven two functions \\(f(n)\\) and \\(g(n)\\). The function \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\) (order of \\(g(n)\\)) if \\(\\exists\\ c,n_0\\textit{ s.t. }f(n)\\leq cg(n)\\forall n\\geq n_0\\)\n\n\n\n\n\n\n\n\nWarning\n\n\n\nA function \\(f(n)\\) is Big-Oh of \\(g(n)\\) if \\(f(n)\\leq cg(n)\\) for large values of \\(n\\). That is, \\(f(n)\\) is dominant by some multiple of \\(g(n)\\) when \\(n\\) is large.\n\n\n\n\n\n\n\n\nTip 5: Examples of Big-Oh Notation\n\n\n\n\n\n\\(f(n)=2n+10\\) is \\(\\mathcal{O}(n)\\).\nProof. For \\(n&gt;10\\), we have \\(2n+10&lt;3n\\). Therefore, we found \\(c=3\\) and \\(n_0=10\\) for which \\(f(n)\\leq cg(n)\\) when \\(n\\geq n_0\\).\n\n\\(\\quad\\text{Q.E.D.}\\ \\blacksquare\\)\n\n\nHowever, we know that \\(f(n)=n^2\\) is not \\(\\mathcal{O}(n)\\). Picking \\(n=c+1\\), the condition \\(n\\leq c\\) will never be satisfied.\n\n\n\n\n\nBig-Oh and Growth rate\n\nThe Big-Oh notation gives an upper bound on the growth rate of a function \\(f(n)\\) that represents the run time complexity of some algorithm\nIf \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\), then the growth rate of \\(f(n)\\) is no more than the growth rate of \\(g(n)\\).\nIn algorithm analysis, we use \\(\\mathcal{O}(g(n))\\) to rank (=categorize) functions by their growth rate.\n\n\n\n\n\n\n\n\nTip 6: Examples of Growth Rate\n\n\n\n\n\n\\(2n+4\\), \\(7n+9\\), \\(10000n+999\\) are all \\(\\mathcal{O}(n)\\), so in algorithm analysis we consider all these functions grow at the same rate.\n\n\n\n\nCommon Running Times:\n\n\n\nRunning Time\nName\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nConstant Time\n\n\n\\(\\mathcal{O}(\\log(n))\\)\nLogarithmic\n\n\n\\(\\mathcal{O}(n)\\)\nLinear\n\n\n\\(\\mathcal{O}(n\\log(n))\\)\nLog Linear\n\n\n\\(\\mathcal{O}(n^2)\\)\nQuadratic\n\n\n\n\n\n\n\n\nTriangular Sums: \\[1+2+3+4+\\cdots+N=\\dfrac{N(N+1)}{2}\\approx\\dfrac{N^2}{2}.\\]\nGeometric Sums: \\[1+2+4+8+\\cdots+N(=2^n)=2N-1\\approx 2N\\] \\[1+\\dfrac{1}{2}+\\dfrac{1}{4}+\\cdots+\\dfrac{1}{N}(=\\dfrac{1}{2^n})=2-\\dfrac{1}{N}\\approx2\\]\nHarmonic Sum: \\[1+\\dfrac{1}{2}+\\dfrac{1}{3}+\\cdots+\\dfrac{1}{N}\\approx\\ln(N)\\]\nSterling’s Approximation: \\[\\log(1)+\\log(2)+\\log(3)+\\cdots+\\log(N)=\\log(N!)\\approx N\\log(N)\\]"
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#intro-to-algorithm-analysis",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#intro-to-algorithm-analysis",
    "title": "Lecture 11 Complexity Analysis",
    "section": "",
    "text": "We want to know how can we measure the “goodness” of a program/algorithm?\nWe have some ways to measure:\n\nRunning time (the shorter, the better)\nMemory utilization (the less the better)\nAmount of code (?)\nEtc.\n\nThe most commonly used performance measure is the running time.\nTo measure running time, we can use a stop watch (i.e., use real time as measure). However, there are some problems associated:\n\nThe same program can have different running time on different computers\nDifferent inputs can result in different running time - hard to find their relationship\n\nSo, we need to rely on an more objective measure: count the number of instructions executed by a program for a given input size.\nHowever, this measure is not practical. In practice, we will count the number of “primitive operations” executed by a program for a given input size.\nAlgorithms make repeated steps towards the solution. The primitive operation is a step in the algorithm.\n\nfor (int i = 0; i &lt; N; i++) {\n    S1;\n    S2;\n    ...\n    SN\n}\nThe primitive operation of this algorithm consists of the statementS1; S2; ...; SN.\n\nPrinciples of Algorithm Analysis\n\nAlgorithm analysis consists of\n\nDetermine frequency (=count) of primitive operations\nCharacterize the frequency as a function of the input size\n\nThe algorithm analysis must\n\nTake into account all possible inputs (good ones and bad ones)\nBe independent of hardware/software environment\nBe independent from the programming language\nGive a good estimate that is proportional to the actual running time of the algorihtm\n\n\nGood inputs, Bad inputs, and Average cases\n\nInput data can affect the running time of algorithms\nThe best case are not studied because we cannot count on luck.\nThe worst case gives us an upper bound\n\nThe worst case analysis provides an upper bound on the running time of an algorithm.\nThe analysis is easier to do compare to average case analysis.\n\nThe average case is what we would expect.\n\nTake the average running time over all possible inputs of the same size\nThe analysis depends on input distribution\nThe analysis is harder to do because it uses probability techniques.\n\n\nTechniques used in Algorithm Analysis\n\nThere are two main techniques used in Algorithm Analysis:\n\nLoop analysis\nRecurrence relations\n\nA program spends the most amount of time in loops. One of the technique used in algorithm analysis is loop analysis.\nSome algorithms are recursive. The running time complexity of recursive algorithms are often expressions as recurrence relations. Another technique is solving recurrence relations\n\n\n\n\n\n\n\n\nTip 1: Recurrence Relation\n\n\n\n\n\n\\[ C(n)=2\\times C(n/2)+1 \\]\n\n\n\n\n\n\nConsider the following program fragment, how many times is the loop body executed?\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 2: Solution 1\n\n\n\n\n\n\\[n\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i = i + 2) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 3: Solution 2\n\n\n\n\n\n\\[\\dfrac{n}{2}\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; ++) { \n        sum += array[i] * array[j]; \n    }\n}\n\n\n\n\n\n\nTip 4: Solution 3\n\n\n\n\n\n\\[n\\times n=n^2\\]\n\n\n\n\nThe running time in terms of the input size (\\(n\\)) can be a general mathematical function. However, we are interested in the order of the growth function (but not the exact function).\n\n\n\n\n\n\n\nNote 1: Approximate Definition of Order, Similar/\\(\\sim\\)\n\n\n\nGiven 2 functions \\(f(x)\\) and \\(g(x)\\), we say \\(f(x)\\sim g(x)\\) if \\(\\dfrac{f(x)}{g(x)}=1\\) when \\(n\\to\\infty\\).\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn running time analysis, we can ignore the less significant terms.\n\n\n\n\n\n\n\n\nNote 2: Precise Definition of Order, \\(\\mathcal{O}\\) notation\n\n\n\nGiven two functions \\(f(n)\\) and \\(g(n)\\). The function \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\) (order of \\(g(n)\\)) if \\(\\exists\\ c,n_0\\textit{ s.t. }f(n)\\leq cg(n)\\forall n\\geq n_0\\)\n\n\n\n\n\n\n\n\nWarning\n\n\n\nA function \\(f(n)\\) is Big-Oh of \\(g(n)\\) if \\(f(n)\\leq cg(n)\\) for large values of \\(n\\). That is, \\(f(n)\\) is dominant by some multiple of \\(g(n)\\) when \\(n\\) is large.\n\n\n\n\n\n\n\n\nTip 5: Examples of Big-Oh Notation\n\n\n\n\n\n\\(f(n)=2n+10\\) is \\(\\mathcal{O}(n)\\).\nProof. For \\(n&gt;10\\), we have \\(2n+10&lt;3n\\). Therefore, we found \\(c=3\\) and \\(n_0=10\\) for which \\(f(n)\\leq cg(n)\\) when \\(n\\geq n_0\\).\n\n\\(\\quad\\text{Q.E.D.}\\ \\blacksquare\\)\n\n\nHowever, we know that \\(f(n)=n^2\\) is not \\(\\mathcal{O}(n)\\). Picking \\(n=c+1\\), the condition \\(n\\leq c\\) will never be satisfied.\n\n\n\n\n\nBig-Oh and Growth rate\n\nThe Big-Oh notation gives an upper bound on the growth rate of a function \\(f(n)\\) that represents the run time complexity of some algorithm\nIf \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\), then the growth rate of \\(f(n)\\) is no more than the growth rate of \\(g(n)\\).\nIn algorithm analysis, we use \\(\\mathcal{O}(g(n))\\) to rank (=categorize) functions by their growth rate.\n\n\n\n\n\n\n\n\nTip 6: Examples of Growth Rate\n\n\n\n\n\n\\(2n+4\\), \\(7n+9\\), \\(10000n+999\\) are all \\(\\mathcal{O}(n)\\), so in algorithm analysis we consider all these functions grow at the same rate.\n\n\n\n\nCommon Running Times:\n\n\n\nRunning Time\nName\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nConstant Time\n\n\n\\(\\mathcal{O}(\\log(n))\\)\nLogarithmic\n\n\n\\(\\mathcal{O}(n)\\)\nLinear\n\n\n\\(\\mathcal{O}(n\\log(n))\\)\nLog Linear\n\n\n\\(\\mathcal{O}(n^2)\\)\nQuadratic\n\n\n\n\n\n\n\n\nTriangular Sums: \\[1+2+3+4+\\cdots+N=\\dfrac{N(N+1)}{2}\\approx\\dfrac{N^2}{2}.\\]\nGeometric Sums: \\[1+2+4+8+\\cdots+N(=2^n)=2N-1\\approx 2N\\] \\[1+\\dfrac{1}{2}+\\dfrac{1}{4}+\\cdots+\\dfrac{1}{N}(=\\dfrac{1}{2^n})=2-\\dfrac{1}{N}\\approx2\\]\nHarmonic Sum: \\[1+\\dfrac{1}{2}+\\dfrac{1}{3}+\\cdots+\\dfrac{1}{N}\\approx\\ln(N)\\]\nSterling’s Approximation: \\[\\log(1)+\\log(2)+\\log(3)+\\cdots+\\log(N)=\\log(N!)\\approx N\\log(N)\\]"
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#intro-and-the-big-oh-notation",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#intro-and-the-big-oh-notation",
    "title": "Lecture 11 Complexity Analysis",
    "section": "Intro and the Big-Oh Notation",
    "text": "Intro and the Big-Oh Notation\n\nConsider the following program fragment, how many times is the loop body executed?\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 2: Solution 1\n\n\n\n\n\n\\[n\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i = i + 2) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 3: Solution 2\n\n\n\n\n\n\\[\\dfrac{n}{2}\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; ++) { \n        sum += array[i] * array[j]; \n    }\n}\n\n\n\n\n\n\nTip 4: Solution 3\n\n\n\n\n\n\\[n\\times n=n^2\\]\n\n\n\n\nThe running time in terms of the input size (\\(n\\)) can be a general mathematical function. However, we are interested in the order of the growth function (but not the exact function).\n\n\n\n\n\n\n\nNote 1: Approximate Definition of Order, Similar/\\(\\sim\\)\n\n\n\nGiven 2 functions \\(f(x)\\) and \\(g(x)\\), we say \\(f(x)\\sim g(x)\\) if \\(\\dfrac{f(x)}{g(x)}=1\\) when \\(n\\to\\infty\\).\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn running time analysis, we can ignore the less significant terms.\n\n\n\n\n\n\n\n\nNote 2: Precise Definition of Order, \\(\\mathcal{O}\\) notation\n\n\n\nGiven two functions \\(f(n)\\) and \\(g(n)\\). The function \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\) (order of \\(g(n)\\)) if \\(\\exists\\ c,n_0\\textit{ s.t. }f(n)\\leq cg(n)\\forall n\\geq n_0\\)\n\n\n\n\n\n\n\n\nWarning\n\n\n\nA function \\(f(n)\\) is Big-Oh of \\(g(n)\\) if \\(f(n)\\leq cg(n)\\) for large values of \\(n\\). That is, \\(f(n)\\) is dominant by some multiple of \\(g(n)\\) when \\(n\\) is large.\n\n\n\n\n\n\n\n\nTip 5: Examples of Big-Oh Notation\n\n\n\n\n\n\\(f(n)=2n+10\\) is \\(\\mathcal{O}(n)\\).\nProof. For \\(n&gt;10\\), we have \\(2n+10&lt;3n\\). Therefore, we found \\(c=3\\) and \\(n_0=10\\) for which \\(f(n)\\leq cg(n)\\) when \\(n\\geq n_0\\).\n\n\\(\\quad\\text{Q.E.D.}\\ \\blacksquare\\)\n\n\nHowever, we know that \\(f(n)=n^2\\) is not \\(\\mathcal{O}(n)\\). Picking \\(n=c+1\\), the condition \\(n\\leq c\\) will never be satisfied.\n\n\n\n\n\nBig-Oh and Growth rate\n\nThe Big-Oh notation gives an upper bound on the growth rate of a function \\(f(n)\\) that represents the run time complexity of some algorithm\nIf \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\), then the growth rate of \\(f(n)\\) is no more than the growth rate of \\(g(n)\\).\nIn algorithm analysis, we use \\(\\mathcal{O}(g(n))\\) to rank (=categorize) functions by their growth rate.\n\n\n\n\n\n\n\n\nTip 6: Examples of Growth Rate\n\n\n\n\n\n\\(2n+4\\), \\(7n+9\\), \\(10000n+999\\) are all \\(\\mathcal{O}(n)\\), so in algorithm analysis we consider all these functions grow at the same rate.\n\n\n\n\nCommon Running Times:\n\n\n\nRunning Time\nName\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nConstant Time\n\n\n\\(\\mathcal{O}(\\log(n))\\)\nLogarithmic\n\n\n\\(\\mathcal{O}(n)\\)\nLinear\n\n\n\\(\\mathcal{O}(n\\log(n))\\)\nLog Linear\n\n\n\\(\\mathcal{O}(n^2)\\)\nQuadratic\n\n\n\n\n\nUseful Formula in Algorithm Analysis\n\nTriangular Sums: \\[1+2+3+4+\\cdots+N=\\dfrac{N(N+1)}{2}\\approx\\dfrac{N^2}{2}.\\]\nGeometric Sums: \\[1+2+4+8+\\cdots+N(=2^n)=2N-1\\approx 2N\\] \\[1+\\dfrac{1}{2}+\\dfrac{1}{4}+\\cdots+\\dfrac{1}{N}(=\\dfrac{1}{2^n})=2-\\dfrac{1}{N}\\approx2\\]\nHarmonic Sum: \\[1+\\dfrac{1}{2}+\\dfrac{1}{3}+\\cdots+\\dfrac{1}{N}\\approx\\ln(N)\\]\nSterling’s Approximation: \\[\\log(1)+\\log(2)+\\log(3)+\\cdots+\\log(N)=\\log(N!)\\approx N\\log(N)\\]"
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#useful-formula-in-algorithm-analysis",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#useful-formula-in-algorithm-analysis",
    "title": "Lecture 11 Complexity Analysis",
    "section": "Useful Formula in Algorithm Analysis",
    "text": "Useful Formula in Algorithm Analysis\n\nTriangular Sums: \\[1+2+3+4+\\cdots+N=\\dfrac{N(N+1)}{2}\\approx\\dfrac{N^2}{2}.\\]\nGeometric Sums: \\[1+2+4+8+\\cdots+N(=2^n)=2N-1\\approx 2N\\] \\[1+\\dfrac{1}{2}+\\dfrac{1}{4}+\\cdots+\\dfrac{1}{N}(=\\dfrac{1}{2^n})=2-\\dfrac{1}{N}\\approx2\\]\nHarmonic Sum: \\[1+\\dfrac{1}{2}+\\dfrac{1}{3}+\\cdots+\\dfrac{1}{N}\\approx\\ln(N)\\]\nSterling’s Approximation: \\[\\log(1)+\\log(2)+\\log(3)+\\cdots+\\log(N)=\\log(N!)\\approx N\\log(N)\\]\n\nLoop Analysis}\n\\end{document}"
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#loop-analysis",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#loop-analysis",
    "title": "Lecture 11 Complexity Analysis",
    "section": "Loop Analysis",
    "text": "Loop Analysis\n\\end{document}"
  }
]